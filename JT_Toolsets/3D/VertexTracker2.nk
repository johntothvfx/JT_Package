Group {
 name VertexTracker1
 tile_color 0x9c0000ff
 selected true
 addUserKnob {20 vertexTracker l "Vertex Tracker"}
 addUserKnob {1 CLASSIFICATION +INVISIBLE}
 CLASSIFICATION VertexTracker
 addUserKnob {3 first_frame l "first frame"}
 first_frame 1
 addUserKnob {3 last_frame l " -  " -STARTLINE}
 last_frame 100
 addUserKnob {22 get_viewer_frame_range l "get viewers frame range" -STARTLINE T "n=nuke.thisNode()\ntry:\n    v=nuke.activeViewer().node()\nexcept:\n    nuke.message('No Viewer detected in the script.')\nelse:\n    fr=v\['frame_range'].value().split('-')\n    if not(v\['frame_range_lock'].value()):\n        fr=str(nuke.root().frameRange()).split('-')\n    \n    n\['first_frame'].setValue(int(fr\[0]))\n    n\['last_frame'].setValue(int(fr\[1]))\n\n"}
 addUserKnob {26 ""}
 addUserKnob {22 track l "track selected vertices" T "import nuke\nimport nukescripts\nimport _nukemath\n\n# Ensure Qt is properly imported\ntry:\n    # Prefer Qt.py when available\n    from Qt import QtCore, QtGui, QtWidgets\n    from Qt.QtCore import Qt\nexcept ImportError:\n    try:\n        # PySide2 for default Nuke 11\n        from PySide2 import QtCore, QtGui, QtWidgets\n        from PySide2.QtCore import Qt\n    except ImportError:\n        # Or PySide for Nuke 10\n        from PySide import QtCore, QtGui, QtGui as QtWidgets\n        from PySide.QtCore import Qt\n\nclass GeoTracker:\n    def __init__(self, node):\n        self.node = node\n        self.first_frame = int(node\['first_frame'].value())\n        self.last_frame = int(node\['last_frame'].value())\n        self.vertex_animations = \{\}\n        self.container = None\n        self.initial_selection = None\n        self.was_paused = False  # Track if the viewer was originally paused\n    \n    def retrieve_initial_selection(self):\n        self.initial_selection = nukescripts.snap3d.getSelection()\n        if not self.initial_selection:\n            nuke.message(\"No vertices selected.\")\n            return False\n        self.vertex_animations = \{v.index: (\[], \[], \[]) for v in self.initial_selection\}\n        return True\n\n    def create_group_node(self):\n        self.container = nuke.createNode('Group')\n        self.container.setName('MatchPoints')\n        self.container\['tile_color'].setValue(3489595647)\n        self.container.setXpos(self.node.xpos() + 150)\n        self.container.setYpos(self.node.ypos() + 100)\n\n        with self.container:\n            nuke.nodes.Input().setName('camera')\n            nuke.nodes.Output()\n            self.container.addKnob(nuke.Tab_Knob('Controls', 'Match Points'))\n            self.container.addKnob(nuke.Format_Knob('fmt', 'Format'))\n            \n            self.container.addKnob(nuke.Text_Knob('divider1', ''))  # Divider line\n            \n            points_to_tracker_btn = nuke.PyScript_Knob('points_to_tracker', 'Points to Tracker')\n            points_to_axis_btn = nuke.PyScript_Knob('points_to_axis', 'Points to Axis')\n            \n            points_to_axis_btn.clearFlag(nuke.STARTLINE)\n            \n            self.container.addKnob(points_to_tracker_btn)\n            self.container.addKnob(points_to_axis_btn)\n            \n            self.container.addKnob(nuke.Text_Knob('divider2', ''))  # Divider line\n\n            # Set commands for buttons\n            self.set_points_to_tracker_command()\n            self.set_points_to_axis_command()\n\n    def collect_positions(self):\n        with self.container:  # Ensure CurveTool and FrameHold are created inside the Group node\n            curve_tool = nuke.createNode('CurveTool', inpanel=False)\n            frame_hold = nuke.createNode('FrameHold', inpanel=False)\n            frame_hold.setInput(0, self.node.input(0))  # Connect FrameHold to the input geometry\n\n        progressBar = nuke.ProgressTask(\"Tracking Selected Input Geo Points\")\n        total_frames = self.last_frame - self.first_frame + 1\n        progress = 100.0 / max(1.0, total_frames)\n\n        for frame in range(self.first_frame, self.last_frame + 1):\n            if progressBar.isCancelled():\n                break\n\n            # Update the FrameHold node to the current frame\n            frame_hold\['first_frame'].setValue(frame)\n\n            # Update the current frame in Nuke\n            nuke.frame(frame)\n\n            progressBar.setMessage(f'Tracking frame \{frame\}')\n            progressBar.setProgress(int((frame - self.first_frame) * progress))\n\n            # Execute the CurveTool node to gather data for the current frame\n            nuke.execute(curve_tool, frame, frame)\n\n            # Get the vertex positions from the selected geometry\n            selection = nukescripts.snap3d.getSelection()\n\n            for v in selection:\n                x, y, z = self.vertex_animations\[v.index]\n                x.append((frame, v.position.x))\n                y.append((frame, v.position.y))\n                z.append((frame, v.position.z))\n\n        # Clean up\n        nuke.delete(curve_tool)\n        nuke.delete(frame_hold)\n        progressBar.setProgress(100)\n        progressBar.setMessage(\"Tracking completed.\")\n        del progressBar\n\n    def add_animation_data_to_group(self):\n        for vertex_id, (x_keys, y_keys, z_keys) in self.vertex_animations.items():\n            axis_knob = nuke.Array_Knob(f'Axis_\{vertex_id\}', f'Obj: 0 Vertex: \{vertex_id\}', 3)\n            axis_knob.setFlag(nuke.STARTLINE)\n            self.container.addKnob(axis_knob)\n\n            axis_knob.setAnimated()\n            for frame, value in sorted(x_keys):\n                axis_knob.setValueAt(value, frame, 0)\n            for frame, value in sorted(y_keys):\n                axis_knob.setValueAt(value, frame, 1)\n            for frame, value in sorted(z_keys):\n                axis_knob.setValueAt(value, frame, 2)\n\n    def set_points_to_axis_command(self):\n        points_to_axis_cmd = '''\nimport nuke\n\ncontainer = nuke.thisNode()\ngeo_tracker = nuke.toNode(\"\{geo_tracker_name\}\")\n\nx_pos = container.xpos() + 150\ny_pos = container.ypos() + 100\n\nnuke.root().begin()\ntry:\n    for pp, i in enumerate(\[container\[i] for i in container.knobs() if i.startswith('Axis_')]):\n        axis_node = nuke.createNode('Axis3')\n        axis_node.setName(i.name())\n        axis_node\['translate'].fromScript(i.toScript())\n        axis_node.setXpos(x_pos + 150 * pp)\n        axis_node.setYpos(y_pos)\n        axis_node.setInput(0, None)\nfinally:\n    container.begin()\n'''\n        self.container\['points_to_axis'].setValue(points_to_axis_cmd.format(geo_tracker_name=self.node.name()))\n\n    def set_points_to_tracker_command(self):\n        points_to_tracker_cmd = '''\nimport math \ndef findC(cls='Camera',node=nuke.thisNode(),inp=0):\n    obj=node.input(inp)\n    if obj==None:\n        return False\n    if cls in obj.Class():\n        return obj\n    else:\n        return findC(cls,obj,0)\n\ndef camPMatrix(cameraNode,theFrame,fmt): \n\n    tempMatrix=cameraNode\['world_matrix'].getValueAt(theFrame)\n    theMatrix=nuke.math.Matrix4()\n    for j in range(4):\n        for i in range(4):\n            theMatrix\[(j*4+i)]=tempMatrix\[i*4+j]\n   \n    camTransform = theMatrix.inverse()\n\n    roll = float(cameraNode\['winroll'].getValueAt(theFrame)) \n    scale_x, scale_y = \[float(v) for v in cameraNode\['win_scale'].getValueAt(theFrame)] \n    translate_x, translate_y = \[float(v) for v in cameraNode\['win_translate'].getValueAt(theFrame)] \n    m = nuke.math.Matrix4() \n    m.makeIdentity() \n    m.rotateZ(math.radians(roll)) \n    m.scale(1.0 / scale_x, 1.0 / scale_y, 1.0) \n    m.translate(-translate_x, -translate_y, 0.0) \n\n    focal_length = float(cameraNode\['focal'].getValueAt(theFrame)) \n    h_aperture = float(cameraNode\['haperture'].getValueAt(theFrame)) \n    near = float(cameraNode\['near'].getValueAt(theFrame)) \n    far = float(cameraNode\['far'].getValueAt(theFrame)) \n    projection_mode = int(cameraNode\['projection_mode'].getValueAt(theFrame)) \n    p = nuke.math.Matrix4() \n    p.projection(focal_length / h_aperture, near, far, projection_mode == 0) \n\n    fw=float(fmt.width())\n    fh=float(fmt.height())\n    pxa=float(fmt.pixelAspect())\n    asr=fw/(fh/pxa)\n\n    imageAspect = fh / fw\n    t = nuke.math.Matrix4() \n    t.makeIdentity() \n    t.translate( 1.0, 1.0 - (1.0 - imageAspect / pxa), 0.0 ) \n\n    x_scale = fw *.5\n    y_scale = x_scale * pxa \n    s = nuke.math.Matrix4() \n    s.makeIdentity() \n    s.scale(x_scale, y_scale, 1.0) \n\n    return s * t * p * m * camTransform \n\ndef getScriptedTracks(theCamera):\n    theNode=nuke.thisNode()\n    # Get Format\n    theFormat=theNode\['fmt'].value()\n\n    # Get 3D Knobs\n    knobNames=\[i for i in theNode.knobs() if i.startswith('Axis')]\n\n    # Get Frame Range\n    TheFrameRange=theNode\[knobNames\[0]].getKeyList()\n\n    # Generate Data Array\n    pointsData=\[]\n    for i in knobNames:\n        pointsData.append(\['\{curve ','\{curve '])\n    # For Each Frame\n    for idx,frame in enumerate(TheFrameRange):\n        # Get Cam Matrix\n        camMatrix=camPMatrix(theCamera,frame,theFormat)    \n        # For each Point\n        for pidx,knob in enumerate(knobNames):\n            # Get Point coords \n            point=theNode\[knob].getValueAt(frame)\n            # Calculate Screen Coordinates\n            pt = nuke.math.Vector3(point\[0], point\[1], point\[2]) \n            tPos = camMatrix * nuke.math.Vector4(pt.x, pt.y, pt.z, 1.0)\n            cx, cy = 0, 0\n            if tPos.x != 0:\n                cx = tPos.x / tPos.w\n            if tPos.y != 0:\n                cy = tPos.y / tPos.w\n            # Add Values to X, Y curves\n            pointsData\[pidx]\[0] += 'x\{\} \{\} '.format(frame, cx)\n            pointsData\[pidx]\[1] += 'x\{\} \{\} '.format(frame, cy)\n    \n    scriptString=\"\{ 1 31 \"\n    scriptString+=str(len(knobNames))\n    scriptString+=\" \} \\\\n\{ \{ 5 1 20 enable e 1 \} \\\\n\{ 3 1 75 name name 1 \} \\\\n\{ 2 1 58 track_x track_x 1 \} \\\\n\{ 2 1 58 track_y track_y 1 \} \\\\n\{ 2 1 63 offset_x offset_x 1 \} \\\\n\{ 2 1 63 offset_y offset_y 1 \} \\\\n\{ 4 1 27 T T 1 \} \\\\n\{ 4 1 27 R R 1 \} \\\\n\{ 4 1 27 S S 1 \} \\\\n\{ 2 0 45 error error 1 \} \\\\n\{ 1 1 0 error_min error_min 1 \} \\\\n\{ 1 1 0 error_max error_max 1 \} \\\\n\{ 1 1 0 pattern_x pattern_x 1 \} \\\\n\{ 1 1 0 pattern_y pattern_y 1 \} \\\\n\{ 1 1 0 pattern_r pattern_r 1 \} \\\\n\{ 1 1 0 pattern_t pattern_t 1 \} \\\\n\{ 1 1 0 search_x search_x 1 \} \\\\n\{ 1 1 0 search_y search_y 1 \} \\\\n\{ 1 1 0 search_r search_r 1 \} \\\\n\{ 1 1 0 search_t search_t 1 \} \\\\n\{ 2 1 0 key_track key_track 1 \} \\\\n\{ 2 1 0 key_search_x key_search_x 1 \} \\\\n\{ 2 1 0 key_search_y key_search_y 1 \} \\\\n\{ 2 1 0 key_search_r key_search_r 1 \} \\\\n\{ 2 1 0 key_search_t key_search_t 1 \} \\\\n\{ 2 1 0 key_track_x key_track_x 1 \} \\\\n\{ 2 1 0 key_track_y key_track_y 1 \} \\\\n\{ 2 1 0 key_track_r key_track_r 1 \} \\\\n\{ 2 1 0 key_track_t key_track_t 1 \} \\\\n\{ 2 1 0 key_centre_offset_x key_centre_offset_x 1 \} \\\\n\{ 2 1 0 key_centre_offset_y key_centre_offset_y 1 \} \\\\n\} \\\\n\"\n\n    startFrame=min(TheFrameRange)\n    for pidx,knob in enumerate(knobNames):\n        pointsData\[pidx]=' \{ \{curve K x'+str(startFrame)+' 1\} \"'+knob+'\" '+(pointsData\[pidx]\[0].rstrip()+'\} ')+(pointsData\[pidx]\[1].rstrip()+'\}')\n        pointsData\[pidx]+=\" \{\}  \{\}  1 0 0 \{\}  0 0 0 0 0 0 0 0 0 0  \"\n        pointsData\[pidx]+=(11*(\"\{curve 0 x\"+str(startFrame)+\" 0\} \")+\"   \}\\\\n\")\n        scriptString+=pointsData\[pidx]\n    \n    scriptString+=\"\} \\\\n\"\n    return scriptString\n\ndef createTracker(data):\n    nuke.root().begin()\n    trackNode = nuke.createNode('Tracker4')\n    trackNode\['tracks'].fromScript(data)\n    return trackNode\n\ncamera=findC('Camera',nuke.thisNode(),0)\nif camera==False:\n    nuke.message('Camera Not Found')\nelse:\n    xxx=getScriptedTracks(camera)\n    createTracker(xxx)\n'''\n        self.container\['points_to_tracker'].setValue(points_to_tracker_cmd)\n\n    def get_dag_widgets(self, visible=True):\n        \"\"\" Gets all Qt objects with Viewer in the object name. \"\"\"\n        active = \[]\n        inactive = \[]\n\n        all_widgets = QtWidgets.QApplication.instance().allWidgets()\n        for widget in all_widgets:\n            if \"Viewer\" in widget.objectName():\n                if not visible or (visible and widget.isVisible()):\n                    active.append(widget)\n                if not widget.isVisible():\n                    inactive.append(widget)\n\n        return active, inactive\n\n    def is_viewer_paused(self, widget):\n        \"\"\"Check if the viewer's pause button is checked.\"\"\"\n        for child in widget.findChildren(QtWidgets.QWidget):\n            if \"Pause\" in child.toolTip():\n                return child.isChecked()\n        return False\n\n    def pause_viewers(self, state=True):\n        dag = self.get_dag_widgets()\n        all_viewers = dag\[0] + dag\[1]\n        for v in all_viewers:\n            self.pause_widgets(v, state)\n        return all_viewers\n\n    def pause_widgets(self, parent_widget, state):\n        \"\"\"Find all pause widgets within the parent widget.\"\"\"\n        for child in parent_widget.findChildren(QtWidgets.QWidget):\n            if \"Pause\" in child.toolTip():\n                if state:\n                    if not child.isChecked():\n                        child.click()\n                else:\n                    if child.isChecked():\n                        child.click()\n\n    def execute(self):\n        nuke.root().begin()\n        try:\n            if not self.retrieve_initial_selection():\n                return\n\n            # Check if any viewers were paused\n            dag = self.get_dag_widgets()\n            self.was_paused = any(self.is_viewer_paused(v) for v in dag\[0] + dag\[1])\n\n            # Unpause viewers for tracking\n            self.pause_viewers(state=False)\n\n            self.create_group_node()\n            self.collect_positions()\n            self.add_animation_data_to_group()\n\n            # Re-pause the viewers only if they were paused before\n            if self.was_paused:\n                self.pause_viewers(state=True)\n        finally:\n            self.node.begin()\n\n# Execute the tracking process\ngeo_tracker = GeoTracker(nuke.thisNode())\ngeo_tracker.execute()\n" +STARTLINE}
 addUserKnob {20 info l Info}
 addUserKnob {26 version l "" t "Node version info, for more information look at version log" +STARTLINE T "<br><font size='5'>Vertex Tracker</font><font color=#CD0000> v1.0</font>"}
 addUserKnob {26 divider_001 l "" +STARTLINE}
 addUserKnob {26 bulletpoints l "" t "Overview of the node" +STARTLINE T "<br><strong>•</strong><b>Vertex Tracker</b> tracks selected vertex<br>in the 3D viewport and exports a container<br>code with the information.\n<br><br>\n<b><a href=\"https://johntothvfx.com\" style=\"color:#CD0000;\">John Toth © 2024</a></b><br>"}
 addUserKnob {26 divider_002 l "" +STARTLINE}
 addUserKnob {22 demo l "<a href=\"https://johntothvfx.com\"><span style=\"color:#CD0000\">Tool Demo</span></a>" t "Launches the web page where it will have more documentation or a video about the node." -STARTLINE +INVISIBLE T "nuke.message(\"coming soon\")"}
 addUserKnob {22 log l "<a href=\"https://johntothvfx.com\"><span style=\"color:#CD0000\">Version Log</span></a>" t "Contains information about this node.\n\n- classification\n- context\n- date last modified\n- developer notes\n- version number\n- version log\n- year made" -STARTLINE T "\nversion_number = \"1.0.0\"\ncontext = \"3D\"\nmodified_date = \"28th August 2024\"\ndeveloper = \"John Toth © 2024\"\nsite = \"<a href='website linke here'><span style='color:#BBBBBB'>\"\nlog = \"\"\"\n<br></i><b> v 1.0 </b><i>\n- uses the curve tool to track the animation of selected vertices\n\"\"\"\nthank_you = \"This node is based of Daniel Velikov's Vertex Tracker node\"\n\n# Retrieve node name\nname = nuke.thisNode()\['CLASSIFICATION'].getValue()\n\n# Message components\nheader = \"Version Log:\"\ndlm = \"<b>Date Last Modified: </b>\" + modified_date\nspace = \" \"\nenter = \"<br><br>\"\nupper = \"<b>\"\nlower = \"</b>\"\n\n# Formatted message\nmessage = (\n    f\"\{upper\}\{header\}\{enter\}\"\n    f\"Name: \{lower\}\{name\}<br>\"\n    f\"\{upper\}Version Number: \{lower\}\{version_number\}<br>\"\n    f\"\{upper\}Context: \{lower\}\{context\}\{enter\}\"\n    f\"\{dlm\}\{log\}<br>\"\n    f\"<b>Thank You:</b><br>\{thank_you\}<br>\{enter\}\"\n    f\"</i>\{upper\}\{site\}\{developer\}\{lower\}</span></a>\"\n)\n\n# Display the message\nnuke.message(message)"}
}
 Input {
  inputs 0
  name geo
  label "\[value number]"
  xpos -100
 }
 Output {
  name Output
  xpos -100
  ypos 150
 }
end_group
