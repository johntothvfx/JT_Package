Group {
 name AxisToTracker1
 help "Exports Tracker nodes using Camera and Axis selection\n\nThis is a fast way to reconcile3D axis nodes from worldspace to screenspace."
 onCreate "nuke.thisNode().knob('get_viewer_frame_range').execute()\nnuke.thisNode().knob('onCreate').setValue(\"\")\n\n\n\n\n"
 tile_color 0x9c0000ff
 selected true
 addUserKnob {20 AxisToTracker l "Axis to Tracker"}
 addUserKnob {1 CLASSIFICATION +INVISIBLE}
 CLASSIFICATION AxisToTracker
 addUserKnob {1 output l INVISIBLE +INVISIBLE}
 output "\[value number]"
 addUserKnob {3 number +DISABLED +INVISIBLE}
 addUserKnob {22 lockToggle l lock/unlock -STARTLINE +INVISIBLE T "nuke.thisNode()\['number'].setEnabled( not nuke.thisNode()\['number'].enabled() )"}
 addUserKnob {22 removeKnobs l remove -STARTLINE +INVISIBLE T "import nuke\nimport re\n\ndef removeKnob(knob):\n    node = nuke.thisNode()\n    \n    # Extract the number from the knob's name\n    # Expecting knob names like 'axis1', 'axis2', etc.\n    match = re.search(r\"axis(\\d+)\", knob.name())\n    if not match:\n        return\n    \n    c = match.group(1)\n\n    # Remove all knobs associated with the index\n    for knobName, knob in list(node.knobs().items()):\n        if re.match(f\"axis\{c\}\", knobName):\n            node.removeKnob(knob)\n\n    # Check if there are any more dynamically added knobs\n    if not any(\[re.match(r\"axis\\d+\", k) for k in node.knobs()]):\n        node.knob(\"divider03\").setVisible(False)\n        \n    # Update the number knob\n    num = node\['number'].value() - 1\n    if num < 0:\n        num = 0\n    node\['number'].setValue(num)\n"}
 addUserKnob {17 format t "When the tracker is exported, the format will be used to determine the pixel location in 2D space."}
 addUserKnob {3 first_frame l " frame range" t "The initial frame value will be used to set keyframes on the tracker node."}
 first_frame 1001
 addUserKnob {3 last_frame l " -  " t "The final frame value will be used to set the concluding keyframes on the tracker node." -STARTLINE}
 last_frame 1001
 addUserKnob {22 get_viewer_frame_range l "get viewers frame range" t "Grabs the viewers frame range and adds it to the first and last frame range knob." -STARTLINE T "n=nuke.thisNode()\ntry:\n    v=nuke.activeViewer().node()\nexcept:\n    nuke.message('No Viewer detected in the script.')\nelse:\n    fr=v\['frame_range'].value().split('-')\n    if not(v\['frame_range_lock'].value()):\n        fr=str(nuke.root().frameRange()).split('-')\n    \n    n\['first_frame'].setValue(int(fr\[0]))\n    n\['last_frame'].setValue(int(fr\[1]))\n\n"}
 addUserKnob {3 subFrames l "sub frames" +INVISIBLE}
 addUserKnob {26 ""}
 addUserKnob {26 divider03 l "" +STARTLINE +HIDDEN}
 addUserKnob {22 add l "add selected axis" t "Integrates the translation matrix information from the selected Axis nodes into a generated knob." T "import nuke\nimport re\n\nRemoveKnobCode = \"\"\"nuke.thisNode().knob(\"removeKnobs\").execute(); removeKnob(nuke.thisKnob())\"\"\"\n\ndef addKnob():\n    group_node = nuke.thisNode()\n    \n    # Define the classes we are interested in\n    target_classes = \[\"Axis\", \"Camera\", \"DirectLight\", \"EnvironmentLight\", \"PointLight\", \"SpotLight\", \"Light\", \"Environment\"]\n    \n    # Get selected nodes from the root context\n    root = nuke.root()\n    selected_nodes = \[n for n in root.selectedNodes() if any(re.match(f\"\{cls\}\\\\d*\$\", n.Class()) for cls in target_classes)]\n\n    if not selected_nodes:\n        nuke.message(\"No axis nodes selected.\")\n        return\n\n    index = int(group_node\['number'].value())\n\n    for selected_node in selected_nodes:\n        index += 1\n        group_node\['number'].setValue(index)\n\n        # Create an XYZ_Knob for 3D position\n        name_knob = nuke.XYZ_Knob(f\"axis\{index\}\", f\"axis \{index\}\")\n        name_knob.setFlag(nuke.STARTLINE)\n        name_knob.setTooltip('Position of where the axis will be created from when export is executed.')\n\n        # Set expressions for the world matrix\n        name_knob.setExpression(f\"\{selected_node.fullName()\}.world_matrix.3\", 0)  # X\n        name_knob.setExpression(f\"\{selected_node.fullName()\}.world_matrix.7\", 1)  # Y\n        name_knob.setExpression(f\"\{selected_node.fullName()\}.world_matrix.11\", 2) # Z\n\n        space = nuke.Text_Knob(f\"axis\{index\}_space\", \"\")\n        space.setValue(\"   \")\n        space.clearFlag(nuke.STARTLINE)\n\n        remove_knob = nuke.PyScript_Knob(f\"axis\{index\}_remove\", \"remove\")\n        remove_knob.setValue(RemoveKnobCode)\n        remove_knob.setTooltip('Remove the dynamic \"3D Position\" knob')\n        remove_knob.clearFlag(nuke.STARTLINE)\n\n        order_knobs = \[group_node.knob(k) for k in \[\"divider03\", \"add\", \"clear\", \"export\", \"info\", \"version\", \"divider04\", \"bulletpoints\", \"divider05\", \"demo\", \"log\"]]\n        for knob in order_knobs:\n            group_node.removeKnob(knob)\n\n        for knob in \[name_knob, space, remove_knob]:\n            group_node.addKnob(knob)\n\n        for knob in order_knobs:\n            group_node.addKnob(knob)\n\n    nuke.thisKnob().setFlag(0)\n    group_node.knob(\"divider03\").setVisible(True)\n\naddKnob()\n" +STARTLINE}
 addUserKnob {22 clear t "Clears all generated knobs" -STARTLINE T "import nuke\nimport re\n\ndef knobClear():\n    node = nuke.thisNode()\n    \n    # Remove dynamically added knobs based on their naming pattern\n    for knobName, knob in node.knobs().items():\n        if re.match(r\"axis\\d+\", knobName) or re.match(r\"axis\\d+_space\", knobName) or re.match(r\"axis\\d+_remove\", knobName):\n            node.removeKnob(knob)\n            \n    # Reset visibility and count\n    node.knob(\"divider03\").setVisible(False)\n    node.knob('number').setValue(0)\n\nknobClear()\n"}
 addUserKnob {22 export t "Exports the reconciled values and baked them into a tracker node." -STARTLINE T "import nuke\nimport math\nimport re\n\ndef subRange(start, end, samples=0):\n    samples += 1\n    step = 1.0 / samples\n    rng = \[]\n    for i in range(int(start), int(end)):\n        rng.append(i)\n        for j in range(1, int(samples)):\n            rng.append(i + j * step)\n    rng.append(end)\n    return rng\n\ndef findC(cls='Camera', node=nuke.thisNode(), inp=0):\n    obj = node.input(inp)\n    if obj is None:\n        return False\n    if cls in obj.Class():\n        return obj\n    else:\n        return findC(cls, obj, 0)\n\ndef camPMatrix(cameraNode, theFrame, fmt):\n    tempMatrix = cameraNode\['world_matrix'].getValueAt(theFrame)\n    theMatrix = nuke.math.Matrix4()\n    for j in range(4):\n        for i in range(4):\n            theMatrix\[(j * 4 + i)] = tempMatrix\[i * 4 + j]\n\n    camTransform = theMatrix.inverse()\n\n    roll = float(cameraNode\['winroll'].getValueAt(theFrame))\n    scale_x, scale_y = \[float(v) for v in cameraNode\['win_scale'].getValueAt(theFrame)]\n    translate_x, translate_y = \[float(v) for v in cameraNode\['win_translate'].getValueAt(theFrame)]\n\n    # Apply roll, scaling, and translation\n    m = nuke.math.Matrix4()\n    m.makeIdentity()\n    m.rotateZ(math.radians(roll))\n    m.scale(1.0 / scale_x, 1.0 / scale_y, 1.0)\n    m.translate(-translate_x, -translate_y, 0.0)\n\n    focal_length = float(cameraNode\['focal'].getValueAt(theFrame))\n    h_aperture = float(cameraNode\['haperture'].getValueAt(theFrame))\n    \n    # Projection distance (for field of view calculation)\n    d = -fmt.width() * (focal_length / h_aperture)\n\n    return camTransform, m, roll, scale_x, scale_y, translate_x, translate_y, d\n\ndef getScriptedTracks(theCamera):\n    theNode = nuke.thisNode()\n\n    # Get format from the 'format' knob\n    theFormat = theNode\['format'].value()\n\n    # Extract format info\n    formatWidth = theFormat.width()\n    formatHeight = theFormat.height()\n    pixelAspect = theFormat.pixelAspect()\n    halfFormatWidth = formatWidth * 0.5\n    halfFormatHeight = formatHeight * 0.5\n\n    # Find 3D position knobs (axis_\{number\})\n    knobNames = \[knob.name() for knob in theNode.allKnobs() if re.match(r\"axis\\d+\", knob.name()) and not re.search(r\"_(space|remove)\$\", knob.name())]\n\n    # Get frame range\n    startFrame = int(theNode\['first_frame'].value())\n    endFrame = int(theNode\['last_frame'].value())\n    subSamples = theNode\['subFrames'].value()\n    theFrameRange = subRange(startFrame, endFrame, subSamples)\n\n    # Generate data for each frame\n    pointsData = \[]\n    for i in knobNames:\n        pointsData.append(\['\{curve ', '\{curve '])\n\n    for frame in theFrameRange:\n        camTransform, m, roll, scale_x, scale_y, translate_x, translate_y, d = camPMatrix(theCamera, frame, theFormat)\n\n        for pidx, knob in enumerate(knobNames):\n            point = theNode\[knob].valueAt(frame)\n            pointX, pointY, pointZ = point\[0], point\[1], point\[2]\n\n            # Convert to camera space\n            VW = nuke.math.Vector4(pointX, pointY, pointZ, 1.0)\n            VW = camTransform * VW\n            pointX, pointY, pointZ = VW.x, VW.y, VW.z\n\n            # Projection to 2D screen space\n            ratio = d / pointZ\n            x = pointX * ratio\n            y = pointY * ratio\n\n            # Apply window translation and scaling\n            x = (x - (translate_x * halfFormatWidth)) / scale_x\n            y = (y - (translate_y * halfFormatWidth)) / scale_y\n\n            # Apply camera roll\n            srow = math.sin(math.radians(roll))\n            crow = math.cos(math.radians(roll))\n            X = crow * x - srow * y\n            Y = srow * x + crow * y\n\n            # Apply aspect ratio corrections and adjust for pixel aspect ratio\n            X += halfFormatWidth\n            Y = Y * pixelAspect + halfFormatHeight\n\n            # Add values to X, Y curves\n            pointsData\[pidx]\[0] += 'x\{\} \{\} '.format(frame, X)\n            pointsData\[pidx]\[1] += 'x\{\} \{\} '.format(frame, Y)\n\n    # Assemble the tracker script string\n    scriptString = \"\{ 1 31 \"\n    scriptString += str(len(knobNames))\n    scriptString += \" \} \\n\{ \{ 5 1 20 enable e 1 \} \\n\{ 3 1 75 name name 1 \} \\n\{ 2 1 58 track_x track_x 1 \} \\n\{ 2 1 58 track_y track_y 1 \} \\n\{ 2 1 63 offset_x offset_x 1 \} \\n\{ 2 1 63 offset_y offset_y 1 \} \\n\{ 4 1 27 T T 1 \} \\n\{ 4 1 27 R R 1 \} \\n\{ 4 1 27 S S 1 \} \\n\{ 2 0 45 error error 1 \} \\n\{ 1 1 0 error_min error_min 1 \} \\n\{ 1 1 0 error_max error_max 1 \} \\n\{ 1 1 0 pattern_x pattern_x 1 \} \\n\{ 1 1 0 pattern_y pattern_y 1 \} \\n\{ 1 1 0 pattern_r pattern_r 1 \} \\n\{ 1 1 0 pattern_t pattern_t 1 \} \\n\{ 1 1 0 search_x search_x 1 \} \\n\{ 1 1 0 search_y search_y 1 \} \\n\{ 1 1 0 search_r search_r 1 \} \\n\{ 1 1 0 search_t search_t 1 \} \\n\{ 2 1 0 key_track key_track 1 \} \\n\{ 2 1 0 key_search_x key_search_x 1 \} \\n\{ 2 1 0 key_search_y key_search_y 1 \} \\n\{ 2 1 0 key_search_r key_search_r 1 \} \\n\{ 2 1 0 key_search_t key_search_t 1 \} \\n\{ 2 1 0 key_track_x key_track_x 1 \} \\n\{ 2 1 0 key_track_y key_track_y 1 \} \\n\{ 2 1 0 key_track_r key_track_r 1 \} \\n\{ 2 1 0 key_track_t key_track_t 1 \} \\n\{ 2 1 0 key_centre_offset_x key_centre_offset_x 1 \} \\n\{ 2 1 0 key_centre_offset_y key_centre_offset_y 1 \} \\n\} \\n\{ \\n\"\n\n    startFrame = min(theFrameRange)\n    for pidx, knob in enumerate(knobNames):\n        pointsData\[pidx] = ' \{ \{curve K x' + str(startFrame) + ' 1\} \"' + knob + '\" ' + (pointsData\[pidx]\[0].rstrip() + '\} ') + (pointsData\[pidx]\[1].rstrip() + '\}')\n        pointsData\[pidx] += \" \{\}  \{\}  1 0 0 \{\}  0 0 0 0 0 0 0 0 0 0 \"\n        pointsData\[pidx] += (11 * (\"\{curve 0 x\" + str(startFrame) + \" 0\} \") + \"   \}\\n\")\n        scriptString += pointsData\[pidx]\n\n    scriptString += \"\} \\n\"\n    return scriptString\n\ndef createTracker(data, xpos, ypos):\n    with nuke.root():\n        trackNode = nuke.createNode('Tracker4', inpanel=False)\n        trackNode\['tracks'].fromScript(data)\n        trackNode.setXpos(xpos)\n        trackNode.setYpos(ypos)\n    return trackNode\n\ndef exportTracker():\n    node = nuke.thisNode()\n    \n    # Find the camera using input 0\n    camera = findC('Camera', node, 0)\n    if not camera:\n        nuke.message(\"No Camera found.\")\n        return\n\n    # Generate the track data using axis_\{number\} knobs\n    trackData = getScriptedTracks(camera)\n\n    # Calculate positions for the new nodes\n    selected_node = nuke.thisNode()\n    xpos = selected_node.xpos() + 100\n    ypos = selected_node.ypos() + 100\n\n    # Create the tracker node with the generated data\n    tracker = createTracker(trackData, xpos, ypos)\n\nexportTracker()\n"}
 addUserKnob {20 info l Info}
 addUserKnob {26 version l "" t "Node version info, for more information look at version log" +STARTLINE T "<br><font size='5'>Axis To Tracker</font><font color=#CD0000> v1.0</font>"}
 addUserKnob {26 divider04 l "" +STARTLINE}
 addUserKnob {26 bulletpoints l "" t "Overview of the node" +STARTLINE T "<br><strong>•</strong><b>Axis To Tracker</b> extracts the world matrix<br>information of the selected Axis nodes positions.<br>This data will be used to export Tracker nodes<br>based on the camera and format information.\n<br><br>\n<i>• This is a fast way to reconcile3D mutliple axis<br>nodes at once (worldspace to screenspace)\n</i><br><br>\n<b><a href=\"https://johntothvfx.com\" style=\"color:#CD0000;\">John Toth © 2024</a></b><br>"}
 addUserKnob {26 divider05 l "" +STARTLINE}
 addUserKnob {22 demo l "<a href=\"https://johntothvfx.com\"><span style=\"color:#CD0000\">Tool Demo</span></a>" t "Launches the web page where it will have more documentation or a video about the node." -STARTLINE +INVISIBLE T "nuke.message(\"coming soon\")"}
 addUserKnob {22 log l "<a href=\"https://johntothvfx.com\"><span style=\"color:#CD0000\">Version Log</span></a>" t "contains information about this node.\n\n- classification\n- context\n- date last modified\n- developer notes\n- version number\n- version log\n- year made" -STARTLINE T "\n# Constants\nversion_number = \"1.0.1\"\ncontext = \"3D\"\nmodified_date = \"1 August 2024\"\ndeveloper = \"John Toth © 2024\"\nsite = \"<a href='website linke here'><span style='color:#BBBBBB'>\"\nlog = \"\"\"\n<br></i><b> v 1.0 </b><i>\n- Exports Tracker nodes using Camera and Axis selection\n\"\"\"\nthank_you = \"Special Thanks to Daniel Velikov as the math from worldspace to screenspace (tracker) is his\"\n\n# Retrieve node name\nname = nuke.thisNode()\['CLASSIFICATION'].getValue()\n\n# Message components\nheader = \"Version Log:\"\ndlm = \"<b>Date Last Modified: </b>\" + modified_date\nspace = \" \"\nenter = \"<br><br>\"\nupper = \"<b>\"\nlower = \"</b>\"\n\n# Formatted message\nmessage = (\n    f\"\{upper\}\{header\}\{enter\}\"\n    f\"Name: \{lower\}\{name\}<br>\"\n    f\"\{upper\}Version Number: \{lower\}\{version_number\}<br>\"\n    f\"\{upper\}Context: \{lower\}\{context\}\{enter\}\"\n    f\"\{dlm\}\{log\}<br>\"\n    f\"<b>Thank You:</b><br>\{thank_you\}<br>\{enter\}\"\n    f\"</i>\{upper\}\{site\}\{developer\}\{lower\}</span></a>\"\n)\n\n# Display the message\nnuke.message(message)"}
}
 Input {
  inputs 0
  name Camera
  label "\[value number]"
  xpos -100
  ypos 11
 }
 Output {
  name Output
  xpos -100
  ypos 150
 }
end_group
