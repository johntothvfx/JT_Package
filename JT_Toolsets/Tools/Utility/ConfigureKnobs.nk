NoOp {
 name ConfigureKnobs
 knobChanged "import nuke\n\ndef update_knob_visibility():\n    # Retrieve the node that this script is attached to\n    node = nuke.thisNode()\n\n    # Get the current values of 'operation01' and 'operation02' knobs\n    operation1 = node\['operation01'].value()\n    operation2 = node\['operation02'].value()\n\n    # Reset visibility based on 'operation01'\n    if operation1 == 'node':\n        node\['nodeName'].setVisible(True)\n        node\['nodeKnob'].setVisible(True)\n        node\['picker01'].setVisible(True)\n        node\['clear01'].setVisible(True)\n        node\['newValue'].setVisible(False)\n        node\['clear04'].setVisible(False)\n    elif operation1 == 'custom':\n        node\['nodeName'].setVisible(False)\n        node\['nodeKnob'].setVisible(False)\n        node\['picker01'].setVisible(False)\n        node\['clear01'].setVisible(False)\n        node\['newValue'].setVisible(True)\n        node\['clear04'].setVisible(True)\n    else:\n        # Ensure that if none of the conditions for operation01 are met, related knobs are hidden\n        node\['nodeName'].setVisible(False)\n        node\['nodeKnob'].setVisible(False)\n        node\['newValue'].setVisible(False)\n        node\['clear04'].setVisible(False)\n\n    # Adjust visibility based on 'operation02'\n    if operation2 == 'input':\n        node\['knobName'].setVisible(True)\n        node\['nodeClass'].setVisible(False)\n        node\['picker02'].setVisible(False)\n        node\['clear02'].setVisible(False)\n    elif operation2 == 'selected':\n        node\['knobName'].setVisible(True)\n        node\['nodeClass'].setVisible(False)\n        node\['picker02'].setVisible(False)\n        node\['clear02'].setVisible(False)\n    elif operation2 == 'all':\n        node\['knobName'].setVisible(True)\n        node\['nodeClass'].setVisible(True)\n        node\['picker02'].setVisible(True)\n        node\['clear02'].setVisible(True)\n    else:\n        # Ensure that if none of the conditions for operation02 are met, related knobs are hidden\n        node\['knobName'].setVisible(False)\n        node\['nodeClass'].setVisible(False)\n        node\['picker02'].setVisible(False)\n        node\['clear02'].setVisible(False)\n\n\nupdate_knob_visibility()\n"
 tile_color 0x288264ff
 selected true
 addUserKnob {20 configureKnobs l "Configure Knobs"}
 addUserKnob {1 CLASSIFICATION +INVISIBLE}
 CLASSIFICATION ConfigureKnobs
 addUserKnob {1 output l INVISIBLE +INVISIBLE}
 output "\[value operation02]"
 addUserKnob {1 notInUse l INVISIBLE +INVISIBLE}
 notInUse "\[expr \{\[numvalue initialize] == 1 ? \"\[expr \{\[numvalue operation01] == 0 ? \"(\[value nodeName]: \[value nodeKnob]) \" : \"(\[value newValue])\"\}]\\ntransfer to\\n\[expr \{\[numvalue operation02] == 0 ?  \"(Class: \[value nodeClass] (\[value knobName]))\" : \[numvalue operation02] == 1 ? \"(\[value knobName])\" : \"(\[value knobName])\"\}]\" : \"\"\}]\n"
 addUserKnob {4 operation01 l operation t "Choose the operation mode: \n\n<b>node:</b> Transfer values from a selected node's knob.\n\n<b>custom:</b>  Set a custom value from the for knob you want to transfer to.\n" M {node custom "" "" "" "" "" "" "" "" ""}}
 addUserKnob {1 nodeName l "node name" t "The value that will be transfered from this node, based on the name and knob."}
 addUserKnob {1 nodeKnob l "  knob" t "The value that will be transfered from this node, based on the name and knob." -STARTLINE}
 addUserKnob {22 picker01 l "   node picker   " t "When a node is selected in the node graph, executing this knob opens a popup menu. This menu allows the user to quickly select a knob from the chosen node, automatically populating the node's name and selected knob." -STARTLINE T "import nuke\n\ndef select_knob_from_selected_node():\n    # Get the current node where this script is running\n    this_node = nuke.thisNode()\n\n    # Get the selected nodes, excluding 'thisNode'\n    selected_nodes = \[node for node in nuke.selectedNodes() if node != this_node]\n\n    # Check if exactly one node is selected and it's not 'thisNode'\n    if len(selected_nodes) != 1:\n        nuke.message('Please select one node you want to grab knob propeties from')\n        return None, None\n\n    # The only selected node, which is not 'thisNode'\n    selected_node = selected_nodes\[0]\n\n    # List of knob types to exclude\n    excluded_knob_types = \[\n        \"Tab_Knob\", \"PyScript_Knob\", \"Text_Knob\", \"Help_Knob\", \"Script_Knob\",\n        \"Eyedropper_Knob\", \"Histogram_Knob\", \"LookupCurves_Knob\", \"MultiView_Knob\",\n        \"ViewView_Knob\", \"PythonKnob\", \"Password_Knob\", \"SceneView_Knob\", \"FreeType_Knob\",\n        \"SceneGraph_Knob\", \"PathExpression_Knob\", \"Python_Knob\"\n    ]\n\n    # Function to determine if a knob is not meant to be interacted with by users\n    def is_interactable_knob(knob):\n        # Check against the INVISIBLE flag and the visibility method\n        if knob.getFlag(nuke.INVISIBLE) or not knob.visible():\n            return False\n        # Check if the knob type is in the excluded list\n        if knob.Class() in excluded_knob_types:\n            return False\n        return True\n\n    # Collect only knobs that are interactable and not in the excluded list\n    interactable_knobs = \[knob for knob in selected_node.knobs().values() if is_interactable_knob(knob)]\n\n    # Create a list of knob names for the enumeration pulldown\n    knob_names = ' '.join(knob.name() for knob in interactable_knobs) + ' disable'\n\n    p = nuke.Panel('Select Knob')\n    p.addEnumerationPulldown('Knobs', knob_names)\n    if not p.show():\n        return None, None  # Handle cancel\n\n    knob_name = p.value('Knobs')\n    if knob_name == 'disable':\n        return None, None  # Handle disable selection\n\n    return knob_name, selected_node.name()\n\n# Reference to 'thisNode'\nthis_node = nuke.thisNode()\n\n# Get the selected knob name and the name of the selected node from the user selection\nselected_knob_name, selected_node_name = select_knob_from_selected_node()\n\n# Check if a knob name and node name were selected\nif selected_knob_name and selected_node_name:\n    # Set 'knob' and 'nodeName' on thisNode with the selected knob's name and node's name\n    if this_node.knob('nodeKnob'):\n        this_node.knob('nodeKnob').setValue(selected_knob_name)\n    if this_node.knob('nodeName'):\n        this_node.knob('nodeName').setValue(selected_node_name)\n    print(\"Knob name set to: \{\}, Node name set to: \{\}\".format(selected_knob_name, selected_node_name))\nelse:\n    print(\"No knob selection was made or no node name was returned.\")\n"}
 addUserKnob {22 clear01 l clear t "Clears the node name and knob properties." -STARTLINE T "nuke.thisNode().knob('nodeName').setValue('')\nnuke.thisNode().knob('nodeKnob').setValue('')"}
 addUserKnob {1 newValue l "new value" t "Enter a custom value to be applied to the other nodes knobs. This value will be used when 'Custom' is chosen in the operation mode, allowing for manual control over the knob values in target nodes" +HIDDEN}
 addUserKnob {22 clear04 l clear -STARTLINE +HIDDEN T nuke.thisNode().knob('newValue').setValue('')}
 addUserKnob {26 ""}
 addUserKnob {4 operation02 l operation t "Select the operation mode:\n\n<b>all:</b> Transfer the specified information to all nodes of a given class that have the target knob name.\n\n<b>selected:</b> Transfer the information to the selected nodes that contain the specified knob name.\n\n<b>input:</b> Transfer the information to the node connected to this one, provided it has the specified knob name." M {all selected input "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" ""}}
 operation02 selected
 addUserKnob {1 nodeClass l "node class" t "When 'all' is selected in the operation mode, information will be transferred to all nodes based on their class. Use commas to separate multiple class types." +HIDDEN}
 addUserKnob {22 picker02 l "     add class    " t "When a node is selected in the graph, executing this knob automatically populates the node class. If multiple nodes are selected, their class values will be added to the list without overwriting existing entries." -STARTLINE +HIDDEN T "import nuke\n\ndef update_node_classes():\n    # Get all currently selected nodes from the node graph\n    selected_nodes = nuke.selectedNodes()\n    if not selected_nodes:\n        nuke.message(\"Please select one or more nodes in the Node Graph.\")\n        return\n\n    # Use a set to collect unique class names of each selected node\n    node_classes = set(node.Class() for node in selected_nodes)\n\n    # Reference to thisNode, where the script is attached\n    this_node = nuke.thisNode()\n\n    # Check if 'nodeClass' knob exists on thisNode\n    if 'nodeClass' in this_node.knobs():\n        # Get the current value of the 'nodeClass' knob\n        current_classes = this_node\['nodeClass'].value()\n\n        # If there are existing classes, split them by comma and add to the set\n        if current_classes:\n            existing_classes = set(\[cls.strip() for cls in current_classes.split(',')])\n            node_classes.update(existing_classes)\n\n        # Convert the set to a sorted list\n        sorted_node_classes = sorted(node_classes)\n\n        # Join all unique and sorted class names into a single string, separated by commas\n        class_names = ', '.join(sorted_node_classes)\n\n        # Set the value of the 'nodeClass' knob to the concatenated class names\n        this_node\['nodeClass'].setValue(class_names)\n    else:\n        nuke.message(\"The knob 'nodeClass' does not exist on this node. Please add it.\")\n\nupdate_node_classes()\n"}
 addUserKnob {22 clear02 l clear -STARTLINE +HIDDEN T nuke.thisNode().knob('nodeClass').setValue('')}
 addUserKnob {1 knobName l "knob name" t "Specify the name(s) of the target knob(s) to which the value will be applied. Use commas to separate multiple knob names. The selected operation will transfer the values only to nodes containing these knobs."}
 addUserKnob {22 picker03 l "     add knob    " t "When a node is selected in the node graph, executing this knob opens a popup menu. This menu allows the user to quickly select a knob from the chosen node, automatically populating the knob name." -STARTLINE T "import nuke\n\ndef select_knob_from_selected_node():\n    # Get the current node where this script is running\n    this_node = nuke.thisNode()\n\n    # Get the selected nodes, excluding 'thisNode'\n    selected_nodes = \[node for node in nuke.selectedNodes() if node != this_node]\n\n    # Check if exactly one node is selected and it's not 'thisNode'\n    if len(selected_nodes) != 1:\n        nuke.message('Please select one node you want to grab knob properties from')\n        return None\n\n    # The only selected node, which is not 'thisNode'\n    selected_node = selected_nodes\[0]\n\n    # List of knob types to exclude\n    excluded_knob_types = \[\n        \"Tab_Knob\", \"PyScript_Knob\", \"Text_Knob\", \"Help_Knob\", \"Script_Knob\",\n        \"Eyedropper_Knob\", \"Histogram_Knob\", \"LookupCurves_Knob\", \"MultiView_Knob\",\n        \"ViewView_Knob\", \"PythonKnob\", \"Password_Knob\", \"SceneView_Knob\", \"FreeType_Knob\",\n        \"SceneGraph_Knob\", \"PathExpression_Knob\", \"Python_Knob\"\n    ]\n\n    # Function to determine if a knob is not meant to be interacted with by users\n    def is_interactable_knob(knob):\n        # Check against the INVISIBLE flag and the visibility method\n        if knob.getFlag(nuke.INVISIBLE) or not knob.visible():\n            return False\n        # Check if the knob type is in the excluded list\n        if knob.Class() in excluded_knob_types:\n            return False\n        return True\n\n    # Collect only knobs that are interactable and not in the excluded list\n    interactable_knobs = \[knob for knob in selected_node.knobs().values() if is_interactable_knob(knob)]\n\n    # Create a list of knob names for the enumeration pulldown\n    knob_names = ' '.join(knob.name() for knob in interactable_knobs) + ' disable'\n\n    p = nuke.Panel('Select Knob')\n    p.addEnumerationPulldown('Knobs', knob_names)\n    if not p.show():\n        return None  # Handle cancel\n\n    knob_name = p.value('Knobs')\n    if knob_name == 'disable':\n        return None  # Handle disable selection\n\n    return knob_name\n\n# Reference to 'thisNode'\nthis_node = nuke.thisNode()\n\n# Get the selected knob name from the user selection\nselected_knob_name = select_knob_from_selected_node()\n\n# Check if a knob name was selected\nif selected_knob_name:\n    # Append the selected knob name to the 'knobName' on thisNode\n    if this_node.knob('knobName'):\n        current_knob_name_value = this_node.knob('knobName').value()\n        # Append the new knob name if the field isn't empty, separated by a comma\n        if current_knob_name_value:\n            updated_knob_name_value = f\"\{current_knob_name_value\}, \{selected_knob_name\}\"\n        else:\n            updated_knob_name_value = selected_knob_name\n        this_node.knob('knobName').setValue(updated_knob_name_value)\n    print(f\"Knob name added: \{selected_knob_name\}\")\nelse:\n    print(\"No knob selection was made.\")\n"}
 addUserKnob {22 clear03 l clear t "Clears the knob name properties." -STARTLINE T nuke.thisNode().knob('knobName').setValue('')}
 addUserKnob {26 ""}
 addUserKnob {22 execute t "On execution this will update the nodes based on selected operations." T "import nuke\n\ndef modify_nodes():\n    this_node = nuke.thisNode()\n    \n    # Retrieve values from the knobs\n    operation01 = this_node\['operation01'].value()\n    operation02 = this_node\['operation02'].value()\n    nodeName = this_node\['nodeName'].value()\n    knobName = this_node\['nodeKnob'].value()  # The knob from which we get the value when operation01 == 'node'\n    targetKnobNames = \[k.strip() for k in this_node\['knobName'].value().split(',')]  # Split by comma and strip any spaces\n    nodeClasses = \[c.strip() for c in this_node\['nodeClass'].value().split(',')]  # Split by comma and strip any spaces\n    newValue = this_node\['newValue'].value()  # The custom value to set if operation01 is 'custom'\n\n    # Determine the value to use based on operation01\n    if operation01 == 'custom':\n        # Attempt to convert newValue to a number, if possible\n        try:\n            value = float(newValue)\n        except ValueError:\n            # If conversion fails, treat it as a string\n            value = newValue\n    else:\n        # If operation01 is 'node', fetch the value from the specified node and knob\n        source_node = nuke.toNode(nodeName)\n        if not source_node:\n            nuke.message(\"Specified source node does not exist.\")\n            return\n\n        # Retrieve the value from the source node's specified knob\n        if knobName in source_node.knobs():\n            value = source_node\[knobName].value()  # Use value() to retrieve the value universally\n        else:\n            nuke.message(f\"The knob '\{knobName\}' does not exist on the node '\{nodeName\}'.\")\n            return\n\n    # Ask for user confirmation if operation02 is 'all'\n    if operation02 == 'all':\n        msg = f\"Are you sure you want to modify nodes of class(es) \{', '.join(nodeClasses)\}, setting knobs \{', '.join(targetKnobNames)\} to \{value\}?\"\n        if not nuke.ask(msg):\n            return\n    \n    # Determine which nodes to modify based on operation02\n    nodes_to_modify = \[]\n    if operation02 == 'all':\n        # Modify all nodes of the specified classes\n        for nodeClass in nodeClasses:\n            nodes_to_modify.extend(nuke.allNodes(nodeClass))\n    elif operation02 == 'selected':\n        # Modify only the selected nodes\n        nodes_to_modify = nuke.selectedNodes()\n    elif operation02 == 'input':\n        # Modify the input nodes connected to this node\n        nodes_to_modify = \[this_node.input(i) for i in range(this_node.inputs()) if this_node.input(i) is not None]\n\n    # Set the values on the appropriate knobs in the chosen nodes\n    for node in nodes_to_modify:\n        if node:  # Ensure the node exists\n            for targetKnobName in targetKnobNames:\n                if targetKnobName in node.knobs():\n                    try:\n                        knob = node\[targetKnobName]\n                        # Handle setting the value based on the knob type\n                        if isinstance(knob, nuke.Array_Knob):\n                            knob.setValue(value)  # Set the value directly for array knobs\n                        elif isinstance(knob, nuke.Channel_Knob) or isinstance(knob, nuke.String_Knob):\n                            knob.setValue(str(value))  # Ensure it's treated as a string for channel or string knobs\n                        else:\n                            knob.setValue(float(value))  # Default to setting as a float if possible\n                    except (TypeError, ValueError):\n                        # If the value can't be set due to type incompatibility, ignore and continue\n                        continue\n                    except Exception as e:\n                        nuke.message(f\"Failed to set \{targetKnobName\} on \{node.name()\} due to: \{str(e)\}\")\n                        continue\n\nmodify_nodes()\n" +STARTLINE}
 addUserKnob {20 info l Info}
 addUserKnob {26 version l "" t "Node version info, for more information look at version log" +STARTLINE T "<br><font size='5'>Configure Knobs</font><font color=#288264> v1.0</font>"}
 addUserKnob {26 divider_001 l "" +STARTLINE}
 addUserKnob {26 bulletpoints l "" t "Overview of the node" +STARTLINE T "<br><strong>•</strong><b>Configure Knobs</b> Enables users to apply bulk<br> changes to node knob properties based on the<br>properties of another node or a custom value. \n<br><br>\n<b><a href=\"https://johntothvfx.com\" style=\"color:#288264;\">John Toth © 2024</a></b><br>"}
 addUserKnob {26 divider_002 l "" +STARTLINE}
 addUserKnob {22 demo l "<a href=\"https://johntothvfx.com\"><span style=\"color:#288264\">Tool Demo</span></a>" t "Launches the web page where it will have more documentation or a video about the node." +INVISIBLE T "nuke.message(\"coming soon\")" +STARTLINE}
 addUserKnob {22 log l "<a href=\"https://johntothvfx.com\"><span style=\"color:#288264\">Version Log</span></a>" t "Contains information about this node.\n\n- classification\n- context\n- date last modified\n- developer notes\n- version number\n- version log\n- year made" -STARTLINE T "\nversion_number = \"1.0.0\"\ncontext = \"Utility\"\nmodified_date = \"4th September 2024\"\ndeveloper = \"John Toth © 2024\"\nsite = \"<a href='website linke here'><span style='color:#BBBBBB'>\"\nlog = \"\"\"\n<br></i><b> v 1.0 </b><i>\n- changes bulk node knobs based on another node properties or custom value.\n\"\"\"\nthank_you = \"\"\n\n# Retrieve node name\nname = nuke.thisNode()\['CLASSIFICATION'].getValue()\n\n# Message components\nheader = \"Version Log:\"\ndlm = \"<b>Date Last Modified: </b>\" + modified_date\nspace = \" \"\nenter = \"<br><br>\"\nupper = \"<b>\"\nlower = \"</b>\"\n\n# Formatted message\nmessage = (\n    f\"\{upper\}\{header\}\{enter\}\"\n    f\"Name: \{lower\}\{name\}<br>\"\n    f\"\{upper\}Version Number: \{lower\}\{version_number\}<br>\"\n    f\"\{upper\}Context: \{lower\}\{context\}\{enter\}\"\n    f\"\{dlm\}\{log\}<br>\"\n    #f\"<b>Thank You:</b><br>\{thank_you\}<br>\{enter\}\"\n    f\"</i>\{upper\}\{site\}\{developer\}\{lower\}</span></a>\"\n)\n\n# Display the message\nnuke.message(message)"}
}
