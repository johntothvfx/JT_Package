NoOp {
 name SaveNodeSelection
 help "Saves and restores selections of nodes from the node graph."
 onCreate "import nuke\nimport re\n\nclass NodeSelect:\n    def __init__(self):\n        pass\n\n    def add_knob(self):\n        node = nuke.thisNode()\n    \n        RemoveKnobCode = \"\"\"NodeSelect().removeKnob(nuke.thisKnob())\"\"\"\n        SaveKnobCode = \"\"\"NodeSelect().saveSelection()\"\"\"    \n        restoreKnobCode = \"\"\"NodeSelect().restoreSelection()\"\"\"    \n        clearKnobCode = \"\"\"NodeSelect().clearSelection()\"\"\"   \n    \n        # Get current number of selections\n        index = node\['number'].value() + 1\n        node\['number'].setValue(index)\n        \n        # Find the next available index\n        index = 1\n        while node.knob(f\"selection_\{str(index).zfill(2)\}_name\") is not None:\n            index += 1\n        index_str = str(index).zfill(2)\n        \n        # Create new knobs with the calculated index\n        name_knob = nuke.String_Knob(f\"selection_\{index_str\}_name\", \"name\")\n        name_knob.setTooltip('Name of selection set')\n        name_knob.setFlag(nuke.STARTLINE)\n        \n        restore_selection = nuke.PyScript_Knob(f\"selection_\{index_str\}_restore\", \"restore selection\")\n        restore_selection.setValue(restoreKnobCode)\n        restore_selection.setTooltip('Restores the selection of nodes from the selection saved')\n        restore_selection.clearFlag(nuke.STARTLINE)\n        \n        space = nuke.Text_Knob(f\"selection_\{index_str\}_space\", \"\")\n        space.setValue(\"   \")\n        space.clearFlag(nuke.STARTLINE)\n        \n        save_selection = nuke.PyScript_Knob(f\"selection_\{index_str\}_save\", \"save selection\")\n        save_selection.setValue(SaveKnobCode)\n        save_selection.setTooltip('Saves the selected nodes in the group graph as a selection set')\n        save_selection.clearFlag(nuke.STARTLINE)\n        \n        clear_selection = nuke.PyScript_Knob(f\"selection_\{index_str\}_clear\", \"clear selection\")\n        clear_selection.setValue(clearKnobCode)\n        clear_selection.setTooltip('Clears the saved selection set')\n        clear_selection.clearFlag(nuke.STARTLINE)\n        \n        remove_knob = nuke.PyScript_Knob(f\"selection_\{index_str\}_remove\", \"remove\")\n        remove_knob.setValue(RemoveKnobCode)\n        remove_knob.setTooltip('Remove the dynamic \"selection\" knob')\n        remove_knob.clearFlag(nuke.STARTLINE)\n        \n        store_knob = nuke.String_Knob(f\"selection_\{index_str\}_store\", \"store\")\n        store_knob.setVisible(False)\n        store_knob.setFlag(nuke.STARTLINE)\n        \n        # Re-order the existing knobs\n        order_knobs = \[node.knob(k) for k in \[\"divider03\", \"add\", \"clear\", \"info\", \"version\", \"divider04\", \"bulletpoints\", \"divider05\", \"demo\", \"log\"]]\n        for knob in order_knobs:\n            node.removeKnob(knob)\n        \n        # Add the new knobs\n        for knob in \[name_knob, restore_selection, space, save_selection, clear_selection, remove_knob, store_knob]:\n            node.addKnob(knob)\n        \n        # Re-add the previously removed knobs\n        for knob in order_knobs:\n            node.addKnob(knob)\n        \n        # Finalize the knob setup\n        nuke.thisKnob().setFlag(0)\n        node.knob(\"divider03\").setVisible(True)\n\n    def removeKnob(self,knob):\n        node = nuke.thisNode()\n        \n        # Extract the index from the knob name\n        match = re.search(r\"selection_(\\d\{2\})_remove\", knob.name())\n        if not match:\n            return  # No matching pattern, exit the function\n        \n        index = match.group(1)\n        \n        # Remove knobs associated with the found index\n        for knobName, knobObj in list(node.knobs().items()):\n            if re.match(f\"selection_\{index\}(_.*)?\", knobName):\n                node.removeKnob(knobObj)\n    \n        # Check if there are any remaining selection knobs\n        if not any(re.match(r\"selection_\\d\{2\}\", k) for k in node.knobs()):\n            if node.knob(\"divider03\"):\n                node.knob(\"divider03\").setVisible(False)\n            \n        # Update the 'number' knob which tracks the number of selection knobs added\n        num = node\['number'].value() - 1\n        if num < 0:\n            num = 0\n        node\['number'].setValue(num)\n        \n    def clearAllKnobs(self):\n        node = nuke.thisNode()\n        \n        # Iterate over all knobs and remove ones that match the pattern \"selection_\\d\{2\}(_.*)?\"\n        for knobName, knob in list(node.knobs().items()):\n            if re.match(r\"selection_\\d\{2\}(_.*)?\", knobName):\n                node.removeKnob(knob)\n        \n        # Reset the 'divider03' visibility and the 'number' knob value\n        node.knob(\"divider03\").setVisible(False)\n        node.knob(\"number\").setValue(0)\n\n    def saveSelection(self):\n        node = nuke.thisNode()\n        current_knob = nuke.thisKnob()\n\n        # Extract the 'number' from the current knob's name (e.g., 'selection_01_save')\n        match = re.search(r\"selection_(\\d\{2\})_save\", current_knob.name())\n        if not match:\n            nuke.message(\"Could not identify selection number from knob name.\")\n            return\n\n        index = match.group(1)  # Get the extracted number (e.g., '01')\n\n        # Find the corresponding 'store' knob (e.g., 'selection_01_store')\n        store_knob_name = f\"selection_\{index\}_store\"\n        store_knob = node.knob(store_knob_name)\n        \n        if not store_knob:\n            nuke.message(f\"Store knob \{store_knob_name\} not found.\")\n            return\n        \n        # Get the selected nodes in the node graph\n        selected_nodes = nuke.selectedNodes()\n\n        # If no nodes are selected, show an error message\n        if not selected_nodes:\n            nuke.message(\"Please select one or more nodes to store in the selection.\")\n            return\n\n        # Extract the names of the selected nodes\n        node_names = \[n.name() for n in selected_nodes]\n\n        # Sort the node names alphabetically\n        node_names.sort()\n\n        # Convert the list of names into a comma-separated string\n        names_string = \", \".join(node_names)\n\n        # Store the string in the 'store_knob'\n        store_knob.setValue(names_string)\n\n        # Get the 'name' knob value (e.g., 'selection_01_name')\n        name_knob = node.knob(f\"selection_\{index\}_name\")\n        name_value = name_knob.value() if name_knob else \"\"\n\n        # Show confirmation that the selection has been stored\n        if name_value:\n            nuke.message(f\"Selection '\{name_value\}' has been saved.\")\n        else:\n            nuke.message(\"Selection has been saved.\")\n\n\n    def restoreSelection(self):\n        node = nuke.thisNode()\n        current_knob = nuke.thisKnob()\n\n        # Extract the 'number' from the current knob's name (e.g., 'selection_01_restore')\n        match = re.search(r\"selection_(\\d\{2\})_restore\", current_knob.name())\n        if not match:\n            nuke.message(\"Could not identify selection number from knob name.\")\n            return\n\n        index = match.group(1)  # Get the extracted number (e.g., '01')\n\n        # Find the corresponding 'store' knob (e.g., 'selection_01_store')\n        store_knob_name = f\"selection_\{index\}_store\"\n        store_knob = node.knob(store_knob_name)\n        \n        if not store_knob:\n            nuke.message(f\"Store knob \{store_knob_name\} not found.\")\n            return\n        \n        # Get the stored node names from the store_knob\n        stored_node_names = store_knob.value().split(\", \")\n\n        if not stored_node_names or stored_node_names == \['']:\n            nuke.message(f\"No stored nodes found\")\n            return\n        \n        # Deselect all nodes manually\n        for n in nuke.allNodes():\n            n.setSelected(False)\n        \n        # Keep track of nodes that were not found\n        missing_nodes = \[]\n\n        # Iterate over all nodes in the node graph and select the ones that match the stored names\n        for node_name in stored_node_names:\n            found = False\n            for n in nuke.allNodes():\n                if n.name() == node_name:\n                    n.setSelected(True)\n                    found = True\n                    break\n            if not found:\n                missing_nodes.append(node_name)\n\n        # Get the 'name' knob value (e.g., 'selection_01_name')\n        name_knob = node.knob(f\"selection_\{index\}_name\")\n        name_value = name_knob.value() if name_knob else \"\"\n\n        # Show a confirmation message\n        if missing_nodes:\n            missing_names = \"\\n\".join(missing_nodes)  # Join missing node names with newline characters\n            if name_value:\n                nuke.message(f\"Selection '\{name_value\}' restored, but the following nodes could not be found:\\n\{missing_names\}\")\n            else:\n                nuke.message(f\"Selection restored, but the following nodes could not be found:\\n\{missing_names\}\")\n        else:\n            if name_value:\n                nuke.message(f\"Selection '\{name_value\}' restored successfully.\")\n            else:\n                nuke.message(f\"Selection restored successfully.\")\n\n\n    def clearSelection(self):\n        node = nuke.thisNode()\n        current_knob = nuke.thisKnob()\n\n        # Extract the 'number' from the current knob's name (e.g., 'selection_01_clear')\n        match = re.search(r\"selection_(\\d\{2\})_clear\", current_knob.name())\n        if not match:\n            nuke.message(\"Could not identify selection number from knob name.\")\n            return\n\n        index = match.group(1)\n\n        # Find the corresponding 'store' knob (e.g., 'selection_01_store')\n        store_knob_name = f\"selection_\{index\}_store\"\n        store_knob = node.knob(store_knob_name)\n        \n        if not store_knob:\n            nuke.message(f\"Store knob \{store_knob_name\} not found.\")\n            return\n        \n        # Clear the value of the 'store_knob'\n        store_knob.setValue(\"\")\n\n        # Check the 'name' knob (e.g., 'selection_01_name') for a value\n        name_knob = node.knob(f\"selection_\{index\}_name\")\n        name_value = name_knob.value() if name_knob else \"\"\n\n        # Show a confirmation message based on the presence of a name\n        if name_value:\n            nuke.message(f\"Selection '\{name_value\}' has been cleared.\")\n        else:\n            nuke.message(f\"Selection has been cleared.\")\n\n\n"
 tile_color 0x288264ff
 selected true
 addUserKnob {20 saveNodeSelection l "Save Node Selection"}
 addUserKnob {1 CLASSIFICATION +INVISIBLE}
 CLASSIFICATION SaveSelection
 addUserKnob {3 number +DISABLED +INVISIBLE}
 number 1
 addUserKnob {22 lockToggle l lock/unlock -STARTLINE +INVISIBLE T "nuke.thisNode()\['number'].setEnabled( not nuke.thisNode()\['number'].enabled() )"}
 addUserKnob {1 selection_01_name l name t "Name of selection set"}
 addUserKnob {22 selection_01_restore l "restore selection" t "Restores the selection of nodes from the selection saved" -STARTLINE T NodeSelect().restoreSelection()}
 addUserKnob {26 selection_01_space l "" -STARTLINE T "   "}
 addUserKnob {22 selection_01_save l "save selection" t "Saves the selected nodes in the group graph as a selection set" -STARTLINE T NodeSelect().saveSelection()}
 addUserKnob {22 selection_01_clear l "clear selection" t "Clears the saved selection set" -STARTLINE T NodeSelect().clearSelection()}
 addUserKnob {22 selection_01_remove l remove t "Remove the dynamic \"selection\" knob" -STARTLINE T NodeSelect().removeKnob(nuke.thisKnob())}
 addUserKnob {1 selection_01_store l store +HIDDEN}
 addUserKnob {26 divider03 l "" +STARTLINE}
 addUserKnob {22 add t "Adds a new dynamic knob to save/restore another selection." T NodeSelect().add_knob() +STARTLINE}
 addUserKnob {22 clear l "clear all" t "Removes and Clears all dynamic selections and knobs" -STARTLINE T "NodeSelect().clearAllKnobs()\n"}
 addUserKnob {20 info l Info}
 addUserKnob {26 version l "" t "Node version info, for more information look at version log" +STARTLINE T "<br><font size='5'>Save Node Selection</font><font color=#288264> v1.0</font>"}
 addUserKnob {26 divider04 l "" +STARTLINE}
 addUserKnob {26 bulletpoints l "" t "Overview of the node" +STARTLINE T "<br><strong>•</strong><b> Save Node Selection</b> allows users to save and<br>restore selections of nodes from the<br>node graph.\n<br><br>\n<b><a href=\"https://johntothvfx.com\" style=\"color:#288264;\">John Toth © 2024</a></b><br>"}
 addUserKnob {26 divider05 l "" +STARTLINE}
 addUserKnob {22 demo l "<a href=\"https://johntothvfx.com\"><span style=\"color:#288264\">Tool Demo</span></a>" t "Launches the web page where it will have more documentation or a video about the node." +INVISIBLE T "nuke.message(\"coming soon\")" +STARTLINE}
 addUserKnob {22 log l "<a href=\"https://johntothvfx.com\"><span style=\"color:#288264\">Version Log</span></a>" t "Contains information about this node.\n\n- classification\n- context\n- date last modified\n- developer notes\n- version number\n- version log\n- year made" -STARTLINE T "\nversion_number = \"1.0.0\"\ncontext = \"Utility\"\nmodified_date = \"10th September 2024\"\ndeveloper = \"John Toth © 2024\"\nsite = \"<a href='website linke here'><span style='color:#BBBBBB'>\"\nlog = \"\"\"\n<br></i><b> v 1.0 </b><i>\n- saved and restore selections in the node graph\n\"\"\"\nthank_you = \"\"\n\n# Retrieve node name\nname = nuke.thisNode()\['CLASSIFICATION'].getValue()\n\n# Message components\nheader = \"Version Log:\"\ndlm = \"<b>Date Last Modified: </b>\" + modified_date\nspace = \" \"\nenter = \"<br><br>\"\nupper = \"<b>\"\nlower = \"</b>\"\n\n# Formatted message\nmessage = (\n    f\"\{upper\}\{header\}\{enter\}\"\n    f\"Name: \{lower\}\{name\}<br>\"\n    f\"\{upper\}Version Number: \{lower\}\{version_number\}<br>\"\n    f\"\{upper\}Context: \{lower\}\{context\}\{enter\}\"\n    f\"\{dlm\}\{log\}<br>\"\n    #f\"<b>Thank You:</b><br>\{thank_you\}<br>\{enter\}\"\n    f\"</i>\{upper\}\{site\}\{developer\}\{lower\}</span></a>\"\n)\n\n# Display the message\nnuke.message(message)"}
}
