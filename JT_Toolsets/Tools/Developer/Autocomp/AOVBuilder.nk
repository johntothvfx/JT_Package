NoOp {
 name AOVBuilder1
 help "AutoComp Builder:\n\nAutomatically builds a composite from AOVs based on category and emission filters.\n\n<b>• 'Build AutoComp'</b> — Generates a full layered comp with shuffles, merges, and premult.\n<b>• 'Extract Leftovers'</b> — Isolates residual RGB content not included in specified layers.\n\nCustomize layout spacing, node colors, and filter logic via the node knobs."
 onCreate "import nuke\n\nclass AutoCompBuild:\n    def __init__(self, node):\n        self.node = node\n        self.input_node = node.input(0)\n        if not self.input_node:\n            raise ValueError(\"Please connect an input to this node before running AutoComp.\")\n\n        self.base_x = int(node.xpos())\n        self.base_y = int(node.ypos())\n\n        self.spacing_unpremult = int(node\['spacing_unpremult'].value())\n        self.spacing_category = int(node\['spacing_category'].value())\n        self.spacing_shuffle = int(node\['spacing_shuffle'].value())\n        self.spacing_composite = int(node\['spacing_composite'].value())\n        self.spacing_merge = int(node\['spacing_merge'].value())\n        self.spacing_premult = int(node\['spacing_premult'].value())\n\n        direction = node\['direction'].value().strip().lower()\n        if direction not in \[\"left\", \"right\"]:\n            raise ValueError(\"Invalid direction. Please choose either 'left' or 'right'.\")\n        self.direction = -1 if direction == \"left\" else 1\n\n        self.category_filters = \[c.strip() for c in node\['category'].value().split(',') if c.strip()]\n        self.emission_filters = \[e.strip() for e in node\['emission'].value().split(',') if e.strip()]\n\n        self.category_color = int(self.node\['category_color'].value())\n        self.emission_color = int(self.node\['emission_color'].value())\n        self.merge_color = int(self.node\['merge_color'].value())\n        self.leftovers_color = int(self.node\['leftovers_color'].value())\n\n        self.unpremult = None\n        self.mainDot = None\n        self.expressionDot = None\n\n        print(\"AutoCompBuild initialized (deferred).\")\n\n    def build(self):\n        self.unpremult = self.create_unpremult()\n        final_dot = self.create_merge_chain()\n        if final_dot:\n            self.create_switch_node(final_dot)\n            print(\"AutoComp build complete.\")\n\n    def create_unpremult(self):\n        unpremult = nuke.nodes.Unpremult(\n            xpos=self.base_x,\n            ypos=self.base_y + self.spacing_unpremult\n        )\n        unpremult.setInput(0, self.node)\n        unpremult\['channels'].setValue('all')\n        return unpremult\n\n    def create_merge_chain(self):\n        channels = self.input_node.channels()\n        allLayers = sorted(set(\[c.split('.')\[0] for c in channels]))\n\n        category_layers = \[layer for layer in allLayers if any(f in layer for f in self.category_filters)]\n        emission_layers = \[layer for layer in allLayers if any(f in layer for f in self.emission_filters)]\n        layers = category_layers + emission_layers\n\n        if not layers:\n            nuke.message(\"No layers found matching the category or emission filters.\")\n            return None\n\n        Xr = self.spacing_category * self.direction\n        Yr = self.spacing_merge\n        layer_index = 1\n\n        mainDot_y = self.unpremult.ypos() + 100\n        self.mainDot = nuke.nodes.Dot(\n            xpos=self.unpremult.xpos() + 34,\n            ypos=mainDot_y\n        )\n        self.mainDot.setInput(0, self.unpremult)\n\n        self.expressionDot = nuke.nodes.Dot(\n            xpos=self.mainDot.xpos() + Xr + 34,\n            ypos=mainDot_y\n        )\n        self.expressionDot.setName(\"expressionDot\")\n        self.expressionDot.setInput(0, self.mainDot)\n\n        leftoverExpr = self.create_leftovers()\n        color_mode = self.node\['node_colors'].value()\n        apply_custom = color_mode == \"custom\"\n        apply_respective = color_mode == \"stream\"\n\n        dotter = self.expressionDot\n        shuffle_nodes = \{\}\n        mergeParent = None\n\n        for layer in layers:\n            dot = nuke.nodes.Dot(\n                xpos=self.expressionDot.xpos() + layer_index * Xr + 34,\n                ypos=mainDot_y\n            )\n            dot.setInput(0, dotter)\n\n            shuffle_y = mainDot_y + 50\n            shuf = nuke.nodes.Shuffle(\n                xpos=self.expressionDot.xpos() + layer_index * Xr,\n                ypos=shuffle_y\n            )\n            shuf\['in'].setValue(layer)\n            shuf\['in2'].setValue('alpha')\n            if apply_custom or apply_respective:\n                tile_color = self.category_color if layer in category_layers else self.emission_color\n                shuf\['tile_color'].setValue(tile_color)\n\n            shuffle_nodes\[layer] = shuf\n\n            shuf\['red'].setValue(\"red\")\n            shuf\['green'].setValue(\"green\")\n            shuf\['blue'].setValue(\"blue\")\n            shuf\['alpha'].setValue(\"alpha2\")\n\n            shuf\['label'].setValue(f'<b>\{layer\}</b> → \[value out]')\n            shuf.setInput(0, dot)\n\n            if layer_index == 1:\n                mergeParent = shuf\n            else:\n                dot2 = nuke.nodes.Dot(\n                    xpos=self.expressionDot.xpos() + 34 + layer_index * Xr,\n                    ypos=mainDot_y + self.spacing_composite + layer_index * Yr\n                )\n                dot2.setInput(0, shuf)\n\n                merge = nuke.nodes.Merge2(\n                    xpos=self.expressionDot.xpos() + Xr,\n                    ypos=mainDot_y + self.spacing_composite + layer_index * Yr - 10\n                )\n                merge\['operation'].setValue('plus')\n                merge\['label'].setValue(layer)\n                if apply_respective and layer in shuffle_nodes:\n                    merge\['tile_color'].setValue(shuffle_nodes\[layer]\['tile_color'].value())\n                elif apply_custom:\n                    merge\['tile_color'].setValue(self.merge_color)\n\n                merge.setInput(0, mergeParent)\n                merge.setInput(1, dot2)\n                mergeParent = merge\n\n            dotter = dot\n            layer_index += 1\n\n        if leftoverExpr:\n            leftoverDot = nuke.nodes.Dot(\n                xpos=self.expressionDot.xpos(),\n                ypos=mainDot_y + self.spacing_composite + layer_index * Yr\n            )\n            leftoverDot.setInput(0, leftoverExpr)\n\n            leftoverMerge = nuke.nodes.Merge2(\n                xpos=self.expressionDot.xpos() + Xr,\n                ypos=mainDot_y + self.spacing_composite + layer_index * Yr - 10\n            )\n            leftoverMerge\['operation'].setValue('plus')\n            leftoverMerge\['label'].setValue(\"Leftovers Merge\")\n            if apply_respective:\n                leftoverMerge\['tile_color'].setValue(leftoverExpr\['tile_color'].value())\n            elif apply_custom:\n                leftoverMerge\['tile_color'].setValue(self.merge_color)\n\n            leftoverMerge.setInput(0, mergeParent)\n            leftoverMerge.setInput(1, leftoverDot)\n            mergeParent = leftoverMerge\n            layer_index += 1\n\n        finalDot_y = mainDot_y + self.spacing_composite + layer_index * Yr\n        finalDot = nuke.nodes.Dot(\n            xpos=self.expressionDot.xpos() + Xr + 34,\n            ypos=finalDot_y\n        )\n        finalDot.setInput(0, mergeParent)\n        return finalDot\n\n    def create_switch_node(self, final_dot):\n        switch = nuke.nodes.Switch(\n            xpos=self.base_x,\n            ypos=final_dot.ypos()\n        )\n        switch\['which'].setValue(1)\n        switch_disabled_color = int(self.node\['switch_disabled_color'].value())\n        switch_enabled_color = int(self.node\['switch_enabled_color'].value())\n        switch_label = (\n            f\"\[expr \{\{(\[value which] && !\[value disable]) ? \\\"U\\\" : \\\"Don't u\\\"\}\}]se (\{', '.join(self.category_filters)\}) \"\n            f\"\[knob tile_color \[expr \{\{(\[value which] && !\[value disable]) ? \{switch_enabled_color\} : \{switch_disabled_color\}\}\}]]\"\n        )\n        switch\['label'].setValue(switch_label)\n        dot_height = final_dot.screenHeight()\n        switch_height = switch.screenHeight()\n        switch_centered_ypos = final_dot.ypos() + (dot_height / 2.0) - (switch_height / 2.0)\n        switch.setYpos(int(switch_centered_ypos))\n        switch.setInput(1, final_dot)\n        switch.setInput(0, self.mainDot)\n\n        side_offset = 200 * self.direction\n        dot1 = nuke.nodes.Dot(\n            xpos=self.mainDot.xpos() - side_offset,\n            ypos=self.mainDot.ypos()\n        )\n        dot1.setInput(0, self.mainDot)\n\n        copy_node = nuke.nodes.Copy(\n            xpos=switch.xpos(),\n            ypos=switch.ypos() + 100\n        )\n        copy_node.setInput(0, switch)\n        copy_node\['from0'].setValue('rgba.alpha')\n        copy_node\['to0'].setValue('rgba.alpha')\n\n        dot2 = nuke.nodes.Dot(\n            xpos=copy_node.xpos() - side_offset + 34,\n            ypos=copy_node.ypos() + 10\n        )\n        dot2.setInput(0, dot1)\n        copy_node.setInput(1, dot2)\n\n        premult_node = nuke.nodes.Premult(\n            xpos=copy_node.xpos(),\n            ypos=copy_node.ypos() + self.spacing_premult\n        )\n        premult_node\['channels'].setValue('all')\n        premult_node.setInput(0, copy_node)\n\n        remove_node = nuke.nodes.Remove(\n            xpos=premult_node.xpos(),\n            ypos=premult_node.ypos() + 100\n        )\n        remove_node.setInput(0, premult_node)\n        remove_node\['operation'].setValue('keep')\n        remove_node\['channels'].setValue('rgba')\n        remove_node\['label'].setValue('\[if \{ \[lsearch \"rgb rgba\"  \[value channels]] != -1 \} \{ return \"(\[value channels])\\n\" \} else \{ return \"\"\}]\[if \{ \[value channels2] != \"none\"\} \{return \"(\[value channels2])\"\} else \{return \" \"\}]\[if \{ \[value channels3] != \"none\"\} \{return \"\\n(\[value channels3])\"\} else \{return \" \"\}]\[if \{ \[value channels4] != \"none\"\} \{return \"\\n(\[value channels4])\"\} else \{return \" \"\}]')\n\n    def create_leftovers(self):\n        try:\n            category_filters = \[c.strip() for c in self.node\['category'].value().split(',') if c.strip()]\n            emission_filters = \[e.strip() for e in self.node\['emission'].value().split(',') if e.strip()]\n            if not category_filters and not emission_filters:\n                return None\n            channels = self.input_node.channels()\n            allLayers = sorted(set(\[c.split('.')\[0] for c in channels]))\n            category_layers = \[layer for layer in allLayers if any(f in layer for f in category_filters)]\n            emission_layers = \[layer for layer in allLayers if any(f in layer for f in emission_filters)]\n            if not category_layers and not emission_layers:\n                return None\n            def expr_sum(layers, ch):\n                return ' + '.join(\[f'(\{layer\}.\{ch\})' for layer in layers]) or '0'\n            r = f\"r - (\{expr_sum(category_layers, 'red')\} + \{expr_sum(emission_layers, 'red')\})\"\n            g = f\"g - (\{expr_sum(category_layers, 'green')\} + \{expr_sum(emission_layers, 'green')\})\"\n            b = f\"b - (\{expr_sum(category_layers, 'blue')\} + \{expr_sum(emission_layers, 'blue')\})\"\n            expr_node = nuke.nodes.Expression(\n                xpos=self.expressionDot.xpos() - 34,\n                ypos=self.expressionDot.ypos() + 50\n            )\n            expr_node.setInput(0, self.expressionDot)\n            expr_node\[\"expr0\"].setValue(r)\n            expr_node\[\"expr1\"].setValue(g)\n            expr_node\[\"expr2\"].setValue(b)\n            label = f\"RGB - \{', '.join(category_filters + emission_filters)\}\"\n            expr_node\[\"label\"].setValue(label)\n            expr_node\['tile_color'].setValue(self.leftovers_color)\n            return expr_node\n        except:\n            return None\n\n    def extract_leftovers_only(self):\n        self.unpremult = self.create_unpremult()\n\n        temp_dot = nuke.nodes.Dot(\n            xpos=self.unpremult.xpos() + 34,\n            ypos=self.unpremult.ypos() + 100\n        )\n        temp_dot.setInput(0, self.unpremult)\n        self.expressionDot = temp_dot\n\n        expr = self.create_leftovers()\n        if expr:\n            expr.setInput(0, self.node)\n            expr.setYpos(self.node.ypos() + 150)\n            expr.setXpos(self.node.xpos())\n            nuke.delete(temp_dot)\n            nuke.delete(self.unpremult)\n        else:\n            nuke.message(\"No leftovers layer could be created.\")\n\n\ndef on_create_autocomp():\n    try:\n        node = nuke.thisNode()\n        if 'build_autocomp' not in node.knobs():\n            node.addKnob(nuke.PyScript_Knob('build_autocomp', 'Build AutoComp', 'run_autocomp_build()'))\n        if 'extract_leftovers' not in node.knobs():\n            node.addKnob(nuke.PyScript_Knob('extract_leftovers', 'Extract Leftovers', 'run_autocomp_extract()'))\n        node\['label'].setValue(\"Ready. Click 'Build AutoComp'\")\n        node\['note_font'].setValue('Verdana Bold')\n        node\['note_font_size'].setValue(20)\n        node\['tile_color'].setValue(0x303030FF)\n        print(\"\[AutoComp] Node initialized safely.\")\n    except Exception as e:\n        nuke.message(f\"\[onCreate] Error: \{e\}\")\n\n\ndef run_autocomp_build():\n    try:\n        node = nuke.thisNode()\n        builder = AutoCompBuild(node)\n        builder.build()\n    except ValueError as e:\n        nuke.message(str(e))\n    except Exception as e:\n        nuke.message(f\"AutoComp Error: \{e\}\")\n\n\ndef run_autocomp_extract():\n    try:\n        node = nuke.thisNode()\n        builder = AutoCompBuild(node)\n        builder.extract_leftovers_only()\n    except ValueError as e:\n        nuke.message(str(e))\n    except Exception as e:\n        nuke.message(f\"AutoComp Extract Error: \{e\}\")\n"
 tile_color 0x192633ff
 note_font "DejaVu Sans"
 selected true
 addUserKnob {20 AOVBuilder l "AOV Builder"}
 addUserKnob {1 CLASSIFICATION +INVISIBLE}
 CLASSIFICATION AOVBuilder
 addUserKnob {1 output l INVISIBLE +INVISIBLE}
 output "\[value direction]"
 addUserKnob {4 direction t "Controls which side the AutoComp stream builds toward.\n\nChoose 'left' or 'right' to align nodes accordingly." M {left right "" "" "" "" "" "" "" "" "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {1 category t "Comma-separated list of category layer name fragments to include.\n\nLayers matching these will be processed first in the AutoComp chain.\n\n<i><b>Example:</b><i>\nlgt,hdri"}
 addUserKnob {3 category_group_value l "" -STARTLINE +INVISIBLE}
 addUserKnob {22 category_group l "   group   " -STARTLINE +INVISIBLE T "import nuke\n\ndef category_group():\n    node = nuke.thisNode()\n    knob = node.knob(\"category_group\")\n    value_knob = node.knob(\"category_group_value\")\n\n    # Set label and value\n    labels = \[\"   group   \", \"don't group\"]\n    mode = int(knob.label() == labels\[1])\n    knob.setLabel(labels\[1 - mode])\n\n    if value_knob is not None:\n        value_knob.setValue(1 - mode)\n\n# Run the function\ncategory_group()\n"}
 addUserKnob {40 category_color l "" t "Tile color used for Shuffle nodes matching category layers when 'node colors' is set to custom or respective stream colors." -STARTLINE}
 category_color 0x9e3c63ff
 addUserKnob {1 emission t "Comma-separated list of emission layer name fragments to include.\n\nThese layers will be merged after category layers."}
 emission emission
 addUserKnob {40 emission_color l "" t "Tile color used for Shuffle nodes matching emission layers when 'node colors' is set to custom or respective stream colors." -STARTLINE}
 emission_color 0xce841aff
 addUserKnob {26 ""}
 addUserKnob {22 build l "   build   " t "Click to build the AOV AutoComp node graph. Creates Unpremult, Shuffle, Merge, Switch, Copy, and other supporting nodes." T run_autocomp_build() +STARTLINE}
 addUserKnob {22 extract t "Subtracts all selected 'category' and 'emission' layers from the RGB.\nResult is what's left over in the image after isolating known layers.\n\nUse this to catch untagged or miscellaneous light passes." -STARTLINE T run_autocomp_extract()}
 addUserKnob {20 spacing l Spacing}
 addUserKnob {26 spacing_title l <b>Spacing</b> +INVISIBLE}
 addUserKnob {3 spacing_unpremult l unpremult t "Vertical distance between the main node and the generated Unpremult node."}
 spacing_unpremult 160
 addUserKnob {3 spacing_category l category t "Horizontal spacing between category/emission streams in the AutoComp layout."}
 spacing_category 500
 addUserKnob {3 spacing_shuffle l shuffle t "Vertical offset applied between Dot nodes and their corresponding Shuffle nodes."}
 spacing_shuffle 50
 addUserKnob {3 spacing_composite l composite t "Vertical offset per layer used to separate composite elements in the Merge tree.\n\nThis is the main area where you will be doing your work in."}
 spacing_composite 500
 addUserKnob {3 spacing_merge l merge t "Additional vertical spacing between each Merge stage. Affects layering depth of streams."}
 spacing_merge 200
 addUserKnob {3 spacing_premult l premult t "Vertical distance between the Copy and Premult nodes in the final comp output."}
 spacing_premult 1000
 addUserKnob {20 colors l Colors}
 addUserKnob {4 node_colors l "node colors" M {"default " custom stream "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" ""}}
 addUserKnob {22 reset_colors l "   reset colors   " -STARTLINE T "node = nuke.thisNode()\n\ndef reset_colors():\n\n    node\['category_color'].setValue(2654757887)\n    node\['emission_color'].setValue(3464764159)\n\n    node\['merge_color'].setValue(1264502527)\n    node\['leftovers_color'].setValue(421934079)\n    node\['switch_enabled_color'].setValue(4290707711)\n    node\['switch_disabled_color'].setValue(1128481791)\n\nreset_colors()\n"}
 addUserKnob {26 ""}
 addUserKnob {26 space000 l "" +STARTLINE T "\t"}
 addUserKnob {40 merge_color l "  merges color " t "Tile color for Merge nodes when 'node colors' is set to 'custom'. Used for all non-stream merges." -STARTLINE}
 merge_color 0x4b5ec6ff
 addUserKnob {26 space001 l "" +STARTLINE T "\t"}
 addUserKnob {40 leftovers_color l "  leftovers color  " t "Tile color for the Expression node representing leftover RGB content. Only used when 'node colors' is 'custom colors' or 'stream'" -STARTLINE}
 leftovers_color 0x192633ff
 addUserKnob {26 space002 l "" +STARTLINE T "\t"}
 addUserKnob {40 switch_enabled_color l "  switch enabled   " t "Tile color for the Switch node when it is enabled (i.e., passing category/emission stream)" -STARTLINE}
 switch_enabled_color 0xffbf00ff
 addUserKnob {26 space003 l "" +STARTLINE T "\t"}
 addUserKnob {40 switch_disabled_color l "  switch disabled   " t "Tile color for the Switch node when it is disabled (i.e., passing the untouched input instead)" -STARTLINE}
 switch_disabled_color 0x434343ff
 addUserKnob {26 space005 l "" +STARTLINE T "\t"}
 addUserKnob {20 info l Info}
 addUserKnob {26 version l "" +STARTLINE T "<br><font size='5'>AOV Matte</font><font color=#141E28> v1.0"}
 addUserKnob {26 ""}
 addUserKnob {26 bulletpoints l "" t "overview of the node" +STARTLINE T "<br><strong>•</br> \n<b>AOVBuilder</b> Automatically builds a composite from<br>AOVs based on category and emission filters.\n<br><br><i>\n • 'Build AutoComp' — Generates a full layered comp<br>with shuffles, merges, and premult.\n<br>\n• 'Extract Leftovers' — Isolates residual RGB content<br>not included in specified layers.\n\n\n\n</i><br><br><b><a href=\"https://johntothvfx.com\" style=\"color:#141E28;\">John Toth <b>© 2025 <br>\n\n"}
 addUserKnob {26 ""}
 addUserKnob {22 demo l "<a href=\"https://johntothvfx.com\"><span style=\"color:#141E28\">Tool Demo" t "Launches the web page where it will have more documentation or a video about the node." +INVISIBLE T "nuke.message('coming soon')" +STARTLINE}
 addUserKnob {22 log l "<a href=\"https://johntothvfx.com\"><span style=\"color:#141E28\">Version Log</a>\n" t "contains information about this node.\n\n- classification\n- context\n- date last modified\n- developer notes\n- version number\n- version log\n- year made" -STARTLINE T "\nversion_number = \"1.0.0\"\ncontext = \"Autocomp\"\nmodified_date = \"16th May 2025\"\ndeveloper = \"John Toth © 2025\"\nsite = \"<a href='https://johntothvfx.com'><span style='color:#BBBBBB'>\"\nlog = \"\"\"\n<br></i><b> v 1.0 </b><i>\n- Builds a composite from AOVs based on category and emission filters.\n\"\"\"\nthank_you = \"\"\n\n# Retrieve node name\nname = nuke.thisNode()\['CLASSIFICATION'].getValue()\n\n# Message components\nheader = \"Version Log:\"\ndlm = \"<b>Date Last Modified: </b>\" + modified_date\nspace = \" \"\nenter = \"<br><br>\"\nupper = \"<b>\"\nlower = \"</b>\"\n\n# Formatted message\nmessage = (\n    f\"\{upper\}\{header\}\{enter\}\"\n    f\"Name: \{lower\}\{name\}<br>\"\n    f\"\{upper\}Version Number: \{lower\}\{version_number\}<br>\"\n    f\"\{upper\}Context: \{lower\}\{context\}\{enter\}\"\n    f\"\{dlm\}\{log\}<br>\"\n    #f\"<b>Thank You:</b><br>\{thank_you\}<br>\{enter\}\"\n    f\"\{upper\}\{site\}\{developer\}\{lower\}</span></a>\"\n)\n\n# Display the message\nnuke.message(message)"}
}
