NoOp {
 name DeepAutoHoldouts
 help "Quick way to holdout Deep elements from eachother. This is achieved based on selection."
 tile_color 0x60ff
 label "\[expr \{\[numvalue create_writes] ? \"create writes:  \[expr \{\[numvalue write_all] ? \"(all) \" : \"rgba\"\}]\" : \"\"\}]"
 selected true
 hide_input true
 addUserKnob {20 deepAutoHoldout l "Deep Auto Holdout"}
 addUserKnob {1 CLASSIFICATION +INVISIBLE}
 CLASSIFICATION DeepAutoHoldout
 addUserKnob {6 create_writes l "create write nodes" t "Create a normal Write node at the end of each held out deep." +STARTLINE}
 create_writes true
 addUserKnob {6 write_all l "set writes to all channels" t "When this node is enabled it will set the Write nodes channels to (all) otherwise by default it will be (rgba)." +STARTLINE}
 write_all true
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {22 holdout l "     holdout     " t "This will automatically hold out deep elements including ScanelineRender nodes from eachother." T "import nuke\nimport re\n\ndef is_valid_node(node):\n    valid_classes = \[\"Group\", \"NoOp\", \"Dot\", \"Gizmo\"]\n    node_class = node.Class()\n    if node_class in valid_classes:\n        return True\n    if node_class.startswith(\"Deep\") and node_class != \"DeepToImage\":\n        return True\n    if re.match(r\"ScanlineRender\\d*\$\", node_class):\n        return True\n    return False\n\ndef main(create_writes, write_all_channels):\n    selected_nodes = nuke.selectedNodes()\n    invalid_nodes = \[node for node in selected_nodes if not is_valid_node(node)]\n    \n    if invalid_nodes:\n        invalid_names = \"\\n- \".join(node.name() for node in invalid_nodes)\n        msg = \"These are not valid deep nodes:\\n\\n- \{\}\\n\\nThey have been excluded from the operation.\".format(invalid_names)\n        nuke.message(msg)\n        selected_nodes = \[node for node in selected_nodes if is_valid_node(node)]\n\n    if len(selected_nodes) == 0:\n        return  # Done\n\n    flattened = \[]\n    \[x.setSelected(False) for x in selected_nodes]\n\n    # Create initial Dot nodes for each selected node\n    initial_dot_nodes = \[]\n    for node in sorted(selected_nodes, key=lambda k: k.xpos()):\n        initial_dot = nuke.createNode('Dot', inpanel=False)\n        initial_dot.setInput(0, node)\n        initial_dot.setXpos(node.xpos() + node.screenWidth() // 2 - initial_dot.screenWidth() // 2)\n        initial_dot.setYpos(node.ypos() + 150)\n        initial_dot\['note_font_size'].setValue(30)\n        initial_dot\['label'].setValue(node.name())\n        initial_dot_nodes.append(initial_dot)\n\n    # Create secondary Dot nodes for each initial Dot node\n    dot_nodes = \[]\n    for initial_dot in initial_dot_nodes:\n        dot = nuke.createNode('Dot', inpanel=False)\n        dot.setInput(0, initial_dot)\n        dot.setXpos(initial_dot.xpos())\n        dot.setYpos(initial_dot.ypos() + 150)\n        dot_nodes.append(dot)\n\n    # Create DeepMerge (holdout) and DeepToImage nodes\n    for i, a in enumerate(sorted(selected_nodes, key=lambda k: k.xpos())):\n        others = \[dot for j, dot in enumerate(dot_nodes) if j != i]\n\n        holdouts = nuke.nodes.DeepMerge(inputs=others)\n        holdouts.setSelected(True)\n        holdouts.setXpos(a.xpos() - 100)\n        holdouts.setYpos(dot_nodes\[i].ypos() + 150)\n\n        with_holdout = nuke.nodes.DeepMerge(inputs=\[dot_nodes\[i], holdouts], operation='holdout')\n        with_holdout.setSelected(True)\n        with_holdout.setXpos(a.xpos())\n        with_holdout.setYpos(holdouts.ypos() + 150)\n\n        dti = nuke.nodes.DeepToImage(inputs=\[with_holdout])\n        dti.setSelected(True)\n        dti.setXpos(a.xpos())\n        dti.setYpos(with_holdout.ypos() + 150)\n\n        if create_writes:\n            w = nuke.createNode('Write', inpanel=False)\n            w.setInput(0, dti)\n            w.setSelected(True)\n            w.setXpos(a.xpos())\n            w.setYpos(dti.ypos() + 200)\n\n            if write_all_channels:\n                w\['channels'].setValue(\"all\")\n            else:\n                w\['channels'].setValue(\"rgba\")\n\n        flattened.append(dti)\n\n    # Determine the rightmost xpos among selected nodes\n    max_xpos = max(node.xpos() for node in selected_nodes)\n\n    # Final DeepMerge (DeepCombine) connected to all secondary Dot nodes\n    final_merge = nuke.nodes.DeepMerge(inputs=dot_nodes, label=\"deep way\")\n    final_merge.setXpos(max_xpos + 150)\n    final_merge.setYpos(dot_nodes\[0].ypos() + 300)  # Align y-position with other DeepMerge nodes\n    final_merge.setSelected(True)\n\n    start = flattened\[0]\n    for x in flattened:\n        if x == start:\n            continue\n        print('merging', start.name(), 'and', x.name())\n        start = nuke.nodes.Merge2(inputs=\[start, x], operation='disjoint-over')\n        start.setSelected(True)\n        start.setXpos(x.xpos() + 150)\n        start.setYpos(x.ypos() + 100)\n\nn = nuke.thisNode()\nmain(n\['create_writes'].value(), n\['write_all'].value())\n" +STARTLINE}
 addUserKnob {20 info l Info}
 addUserKnob {26 version l "" t "Node version info, for more information look at version log" +STARTLINE T "<br><font size='5'>Deep Auto Holdout</font><font color=#000060> v1.1</font>"}
 addUserKnob {26 divider_001 l "" +STARTLINE}
 addUserKnob {26 bulletpoints l "" t "Overview of the node" +STARTLINE T "<br><strong>•</strong><b> Deep Auto Holdout</b> automatically creates holdouts<br>for all selected deep nodes and ScanlineRender nodes,<br>ensuring they are held out from each other.\n\n<br><br>\n<b><a href=\"https://johntothvfx.com\" style=\"color:#000060;\">John Toth © 2024</a></b><br>"}
 addUserKnob {26 divider_002 l "" +STARTLINE}
 addUserKnob {22 demo l "<a href=\"https://johntothvfx.com\"><span style=\"color:#000060\">Tool Demo</span></a>" t "Launches the web page where it will have more documentation or a video about the node." -STARTLINE +INVISIBLE T "nuke.message(\"coming soon\")"}
 addUserKnob {22 log l "<a href=\"https://johntothvfx.com\"><span style=\"color:#000060\">Version Log</span></a>" t "contains information about this node.\n\n- classification\n- context\n- date last modified\n- developer notes\n- version number\n- version log\n- year made" -STARTLINE T "# Constants\nversion_number = \"1.1.1\"\ncontext = \"Deep\"\nmodified_date = \"30th July 2024\"\ndeveloper = \"John Toth © 2018\"\nsite = \"<a href='https://johntothvfx.com'><span style='color:#BBBBBB'>\"\nlog = \"\"\"\n<br></i><b> v 1.0 </b><i>\n- Holdouts deep from each other\n<br></i><b> v 1.1 </b><i>\n- Popup message for nodes that are accepted\n- Write nodes have been added properly to export.\n\"\"\"\nthank_you = \"Special Thanks to Ben Dickson for the help with the coding\"\n\n# Retrieve node name\nname = nuke.thisNode()\['CLASSIFICATION'].getValue()\n\n# Message components\nheader = \"Version Log:\"\ndlm = \"<b>Date Last Modified: </b>\" + modified_date\nspace = \" \"\nenter = \"<br><br>\"\nupper = \"<b>\"\nlower = \"</b>\"\n\n# Formatted message\nmessage = (\n    f\"\{upper\}\{header\}\{enter\}\"\n    f\"Name: \{lower\}\{name\}<br>\"\n    f\"\{upper\}Version Number: \{lower\}\{version_number\}<br>\"\n    f\"\{upper\}Context: \{lower\}\{context\}\{enter\}\"\n    f\"\{dlm\}\{log\}<br>\"\n    f\"<b>Thank You:</b><br>\{thank_you\}<br>\{enter\}\"\n    f\"\{upper\}\{site\}\{developer\}\{lower\}</span></a>\"\n)\n\n# Display the message\nnuke.message(message)\n"}
}
