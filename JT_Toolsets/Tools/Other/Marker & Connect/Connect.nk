Group {
 name Connect
 onCreate "import nuke\n# Set unique name\ni = 1\nwhile nuke.exists('Connect_' + str(i)):\n    i += 1\nnuke.thisNode().setName('Connect_' + str(i))\n# Try auto-reconnect if targetMarker is set\nn = nuke.thisNode()\nif n.knob('parent') and n\['parent'].value():\n    target = n\['parent'].value()\n    with nuke.thisParent():\n        node = nuke.toNode(target)\n        if node:\n            n.setInput(0, node)"
 knobChanged "import nuke\nn = nuke.thisNode()\nk = nuke.thisKnob()\n\nif k.name() == 'parent':\n    target = n\['parent'].value()\n    if target:\n        with nuke.thisParent():\n            node = nuke.toNode(target)\n            if node:\n                n.setInput(0, node)\n                n\['status'].setValue('Connected to: ' + target)\n                n\['tile_color'].setValue(0x4a90e2ff)\n            else:\n                n\['status'].setValue('ERROR: ' + target + ' not found')\n                n\['tile_color'].setValue(0xff4444ff)\n    else:\n        n.setInput(0, None)\n        n\['status'].setValue('No Parent Set')\n        n\['tile_color'].setValue(0x666666ff)\n\nelif k.name() == 'inputChange':\n    target = n\['parent'].value()\n    input_node = n.input(0)\n    \n    if not input_node:\n        n\['tile_color'].setValue(0xff4444ff)\n        if target:\n            n\['status'].setValue('Disconnected from: ' + target)\n        else:\n            n\['status'].setValue('No connection')\n    elif target and input_node.name() == target:\n        n\['tile_color'].setValue(0x4a90e2ff)\n        n\['status'].setValue('(' + target + ')')\n    else:\n        n\['tile_color'].setValue(0xffa500ff)\n        if input_node:\n            n\['status'].setValue('Wrong connection: ' + input_node.name())\n        else:\n            n\['status'].setValue('Connection mismatch')"
 tile_color 0x666666ff
 label "\[value status]"
 selected true
 hide_input true
 addUserKnob {20 Connect}
 addUserKnob {1 CLASSIFICATION l "" +STARTLINE +INVISIBLE}
 CLASSIFICATION Connect
 addUserKnob {1 parent t "Node name of the Marker to connect to"}
 addUserKnob {1 status l Status t "Current connection status" +DISABLED}
 status "No Parent Set"
 addUserKnob {22 connectFromIndex l "connect from index" t "Show popup to select from available markers" T "import nuke\n\ndef show_searchable_marker_selector():\n    # Try to import Qt\n    try:\n        from PySide2 import QtWidgets, QtCore\n        from PySide2.QtCore import Qt\n    except ImportError:\n        try:\n            from PySide import QtGui as QtWidgets\n            from PySide import QtCore\n            from PySide.QtCore import Qt\n        except ImportError:\n            # Fallback to simple choice\n            markers = \[]\n            with nuke.thisParent():\n                for n in nuke.allNodes():\n                    if (hasattr(n, 'knob') and n.knob('CLASSIFICATION') and \n                        n\['CLASSIFICATION'].value() == 'Marker'):\n                        markers.append(n.name())\n            \n            if not markers:\n                nuke.message('No markers found')\n                return None\n            else:\n                choice = nuke.choice('Select Marker', 'Choose marker:', markers)\n                return markers\[choice] if choice is not None else None\n    \n    class SearchableMarkerSelector(QtWidgets.QDialog):\n        def __init__(self, parent=None):\n            super(SearchableMarkerSelector, self).__init__(parent)\n            self.setWindowTitle('Select Marker')\n            self.setModal(True)\n            self.selected_marker = None\n            self.all_markers = \[]\n            self.setupUI()\n            self.populateMarkers()\n            \n        def setupUI(self):\n            layout = QtWidgets.QVBoxLayout()\n            \n            header = QtWidgets.QLabel('Choose a Marker to connect to:')\n            header.setStyleSheet('font-weight: bold; margin-bottom: 5px;')\n            layout.addWidget(header)\n            \n            # Search box\n            search_layout = QtWidgets.QHBoxLayout()\n            search_label = QtWidgets.QLabel('Search:')\n            self.search_box = QtWidgets.QLineEdit()\n            self.search_box.setPlaceholderText('Type to filter markers...')\n            self.search_box.textChanged.connect(self.filterMarkers)\n            search_layout.addWidget(search_label)\n            search_layout.addWidget(self.search_box)\n            layout.addLayout(search_layout)\n            \n            # List widget\n            self.listWidget = QtWidgets.QListWidget()\n            self.listWidget.setMinimumSize(450, 300)\n            layout.addWidget(self.listWidget)\n            \n            # Status label\n            self.status_label = QtWidgets.QLabel('')\n            self.status_label.setStyleSheet('color: #666; font-size: 11px;')\n            layout.addWidget(self.status_label)\n            \n            # Buttons\n            buttonBox = QtWidgets.QDialogButtonBox()\n            self.connectBtn = buttonBox.addButton('Connect', QtWidgets.QDialogButtonBox.AcceptRole)\n            cancelBtn = buttonBox.addButton('Cancel', QtWidgets.QDialogButtonBox.RejectRole)\n            \n            self.connectBtn.setEnabled(False)\n            \n            buttonBox.accepted.connect(self.accept)\n            buttonBox.rejected.connect(self.reject)\n            \n            layout.addWidget(buttonBox)\n            self.setLayout(layout)\n            \n            self.listWidget.itemDoubleClicked.connect(self.accept)\n            self.listWidget.itemSelectionChanged.connect(self.updateConnectButton)\n            \n            self.search_box.setFocus()\n            \n        def populateMarkers(self):\n            self.all_markers = \[]\n            \n            # Search in parent context, not inside the Group\n            with nuke.thisParent():\n                for n in nuke.allNodes():\n                    if (hasattr(n, 'knob') and n.knob('CLASSIFICATION') and \n                        n\['CLASSIFICATION'].value() == 'Marker'):\n                        self.all_markers.append(\{\n                            'node_name': n.name(),\n                            'search_text': n.name().lower()\n                        \})\n            \n            self.all_markers.sort(key=lambda x: x\['node_name'].lower())\n            self.filterMarkers('')\n            \n        def filterMarkers(self, search_text=''):\n            if not hasattr(self, 'search_box'):\n                return\n                \n            search_text = self.search_box.text().lower().strip()\n            self.listWidget.clear()\n            \n            if not self.all_markers:\n                no_markers = QtWidgets.QListWidgetItem('No markers found')\n                no_markers.setFlags(no_markers.flags() & ~Qt.ItemIsSelectable)\n                self.listWidget.addItem(no_markers)\n                self.status_label.setText('No markers available')\n                return\n            \n            if search_text:\n                filtered_markers = \[\n                    marker for marker in self.all_markers \n                    if search_text in marker\['search_text']\n                ]\n            else:\n                filtered_markers = self.all_markers\n            \n            for marker in filtered_markers:\n                item = QtWidgets.QListWidgetItem(marker\['node_name'])\n                item.setData(Qt.UserRole, marker\['node_name'])\n                self.listWidget.addItem(item)\n            \n            total_count = len(self.all_markers)\n            filtered_count = len(filtered_markers)\n            \n            if search_text:\n                if filtered_count == 0:\n                    self.status_label.setText('No matches found (0 of ' + str(total_count) + ' markers)')\n                else:\n                    self.status_label.setText('Showing ' + str(filtered_count) + ' of ' + str(total_count) + ' markers')\n            else:\n                self.status_label.setText(str(total_count) + ' markers available')\n            \n            if self.listWidget.count() > 0 and filtered_markers:\n                self.listWidget.setCurrentRow(0)\n                \n        def updateConnectButton(self):\n            current_item = self.listWidget.currentItem()\n            has_valid_selection = (current_item and \n                                 current_item.data(Qt.UserRole) is not None)\n            self.connectBtn.setEnabled(has_valid_selection)\n            \n        def keyPressEvent(self, event):\n            if event.key() == Qt.Key_Return or event.key() == Qt.Key_Enter:\n                if self.connectBtn.isEnabled():\n                    self.accept()\n                return\n            elif event.key() == Qt.Key_Escape:\n                self.reject()\n                return\n            elif event.key() == Qt.Key_Down:\n                if self.search_box.hasFocus() and self.listWidget.count() > 0:\n                    self.listWidget.setFocus()\n                    self.listWidget.setCurrentRow(0)\n                    return\n            elif event.key() == Qt.Key_Up:\n                if self.listWidget.hasFocus() and self.listWidget.currentRow() == 0:\n                    self.search_box.setFocus()\n                    return\n                    \n            super(SearchableMarkerSelector, self).keyPressEvent(event)\n            \n        def accept(self):\n            current_item = self.listWidget.currentItem()\n            if current_item and current_item.data(Qt.UserRole):\n                self.selected_marker = current_item.data(Qt.UserRole)\n            super(SearchableMarkerSelector, self).accept()\n    \n    try:\n        app = QtWidgets.QApplication.instance()\n        parent = None\n        if app:\n            for widget in app.topLevelWidgets():\n                if widget.metaObject().className() == 'Foundry::UI':\n                    parent = widget\n                    break\n        \n        dialog = SearchableMarkerSelector(parent)\n        if dialog.exec_():\n            return dialog.selected_marker\n        return None\n        \n    except Exception as e:\n        nuke.message('Error creating dialog: ' + str(e))\n        return None\n\n# Execute\n# Store the node reference BEFORE calling the dialog\nconnect_node = nuke.thisNode()\n\nselected_marker = show_searchable_marker_selector()\nif selected_marker:\n    # Use the stored node reference instead of nuke.thisNode()\n    connect_node\['parent'].setValue(selected_marker)" +STARTLINE}
 addUserKnob {22 reconnect t "Force reconnection to target marker" -STARTLINE T "import nuke\nn = nuke.thisNode()\ntarget = n\['parent'].value()\n\nif not target:\n    nuke.message('No target marker set')\nelse:\n    with nuke.thisParent():\n        node = nuke.toNode(target)\n        if node:\n            n.setInput(0, node)\n            nuke.message('Reconnected to: ' + target)\n        else:\n            nuke.message('Target not found: ' + target)"}
 addUserKnob {22 findParent l "find parent" t "Locate and zoom to the target marker" -STARTLINE T "import nuke\nn = nuke.thisNode()\ntarget = n\['parent'].value()\n\nif not target:\n    nuke.message('No target marker set')\nelse:\n    with nuke.thisParent():\n        node = nuke.toNode(target)\n        if node:\n            nuke.zoom(2, \[node.xpos() + node.screenWidth()//2, \n                         node.ypos() + node.screenHeight()//2])\n        else:\n            nuke.message('Target not found: ' + target)"}
 addUserKnob {20 utilities l Utilities}
 addUserKnob {22 findConnected l "find connected" t "Select all Connect nodes that reference the same parent Marker" T "import nuke\nconnect_node = nuke.thisNode()\nparent_name = connect_node\['parent'].value()\n\nprint('=== DEBUG Find Connected ===')\nprint('Current Connect node: ' + connect_node.name())\nprint('Parent name: \"' + str(parent_name) + '\"')\n\nif not parent_name:\n    nuke.message('No parent marker set')\nelse:\n    # Search in parent context, not inside the Group!\n    with nuke.thisParent():\n        # Deselect all\n        for n in nuke.allNodes():\n            n.setSelected(False)\n        \n        found = 0\n        print('Checking all nodes in parent context...')\n        \n        for n in nuke.allNodes():\n            node_name = n.name()\n            \n            # Check if it has parent knob\n            if hasattr(n, 'knob') and n.knob('parent'):\n                try:\n                    node_parent = n\['parent'].value()\n                    print('Node: ' + node_name + ' -> parent: \"' + str(node_parent) + '\"')\n                    \n                    if node_parent == parent_name and n.name() != connect_node.name():\n                        print('  -> MATCH! Selecting ' + node_name)\n                        n.setSelected(True)\n                        found += 1\n                    elif node_parent == parent_name:\n                        print('  -> Match but skipping self: ' + node_name)\n                    else:\n                        print('  -> No match')\n                except Exception as e:\n                    print('  -> Error reading parent: ' + str(e))\n            else:\n                print('Node: ' + node_name + ' -> No parent knob')\n        \n        print('=== DEBUG SUMMARY ===')\n        print('Total found: ' + str(found))\n        print('=====================')\n        \n        if found:\n            nuke.message('Selected ' + str(found) + ' Connect nodes targeting: ' + parent_name)\n        else:\n            nuke.message('No other Connect nodes found targeting: ' + parent_name)" +STARTLINE}
 addUserKnob {22 hideInputToggle l "show input" t "Toggle input visibility" -STARTLINE T "import nuke\n\ndef hideInputToggle():\n    node = nuke.thisNode()\n    knob = node.knob('hideInputToggle')\n    hide_input_knob = node.knob('hide_input')\n    \n    if hide_input_knob is not None:\n        # Toggle the actual hide_input value\n        current_value = hide_input_knob.value()\n        hide_input_knob.setValue(not current_value)\n        \n        # Update button label based on new state\n        if hide_input_knob.value():\n            knob.setLabel('show input')\n        else:\n            knob.setLabel('hide input')\n\n# Run the function\nhideInputToggle()"}
 addUserKnob {22 togglePostageStamp l "show stamp" t "Toggle postage stamp visibility" -STARTLINE T "import nuke\n\ndef togglePostageStamp():\n    node = nuke.thisNode()\n    knob = node.knob('togglePostageStamp')\n    postage_knob = node.knob('postage_stamp')\n    \n    if postage_knob is not None:\n        # Toggle the actual postage_stamp value\n        current_value = postage_knob.value()\n        postage_knob.setValue(not current_value)\n        \n        # Update button label based on new state\n        if postage_knob.value():\n            knob.setLabel('hide stamp')\n        else:\n            knob.setLabel('show stamp')\n\n# Run the function\ntogglePostageStamp()"}
 addUserKnob {20 info l Info}
 addUserKnob {26 version l "" +STARTLINE T "<font size=\"5\">Connect</font><font color=#777777> v1.2</font>"}
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {26 description l "" +STARTLINE T "<strong>•</strong> <b>Connect nodes</b> act as reference points<br>that link back to this marker\n<br><i><br>\n<strong>•</strong> Set the \"parent\" field to the target marker<br>name, then use \"Connect\"\n<br>\n<strong>•</strong> Provides quick navigation and organization<br>in complex node graphs<br> \n<strong>•</strong> Maintains visual connection without affecting<br>the actual node flow<br><br>\n<b><a href=\"https://johntothvfx.com\" style=\"color:#777777;\">John Toth © 2022</a></b><br>"}
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {22 demo l "<a href=\"https://johntothvfx.com\"><span style=\"color:#777777\">Tool Demo</span></a>" t "Launches the web page where it will have more documentation or a video about the node." +INVISIBLE T "nuke.message(\"coming soon\")" +STARTLINE}
 addUserKnob {22 log l "<a href=\"https://johntothvfx.com\"><span style=\"color:#777777\">Version Log</span></a>" t "Contains information about this node.\n\n- classification\n- context\n- date last modified\n- developer notes\n- version number\n- version log\n- year made" -STARTLINE T "\nversion_number = \"1.2.1\"\ncontext = \"Other/Connect\"\nmodified_date = \"5th June 2025\"\ndeveloper = \"John Toth © 2022\"\nsite = \"<a href='website linke here'><span style='color:#BBBBBB'>\"\nlog = \"\"\"\n<br></i><b> v 1.0 </b><i>\n- connects the input of the node based on the parent\n<br></i><b> v 1.1 </b><i>\n- index list was added to keep an list of all connect nodes to speed up workflow.\n<br></i><b> v 1.2 </b><i>\n- index now works through a difference system that works more dynamically\n- marker system implementation has been added\n- cleaner interface\n\"\"\"\nthank_you = \" Special thanks to Samantha Maiolo for earlier development for this tool\"\n\n# Retrieve node name\nname = nuke.thisNode()\['CLASSIFICATION'].getValue()\n\n# Message components\nheader = \"Version Log:\"\ndlm = \"<b>Date Last Modified: </b>\" + modified_date\nspace = \" \"\nenter = \"<br><br>\"\nupper = \"<b>\"\nlower = \"</b>\"\n\n# Formatted message\nmessage = (\n    f\"\{upper\}\{header\}\{enter\}\"\n    f\"Name: \{lower\}\{name\}<br>\"\n    f\"\{upper\}Version Number: \{lower\}\{version_number\}<br>\"\n    f\"\{upper\}Context: \{lower\}\{context\}\{enter\}\"\n    f\"\{dlm\}\{log\}<br>\"\n    f\"<b>Thank You:</b><br>\{thank_you\}<br>\{enter\}\"\n    f\"</i>\{upper\}\{site\}\{developer\}\{lower\}</span></a>\"\n)\n\n# Display the message\nnuke.message(message)"}
}
 Input {
  inputs 0
  name Input
  label "\[value number]"
  xpos 0
  ypos -200
 }
 Output {
  name Output1
  xpos 0
  ypos -100
 }
end_group
