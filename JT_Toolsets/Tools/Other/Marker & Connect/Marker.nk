NoOp {
 name Marker
 onCreate "import nuke\n\ndef clean_name(name):\n    \"\"\"Clean and sanitize node name by replacing spaces/hyphens with underscores\"\"\"\n    return name.replace(' ', '_').replace('-', '_')\n\ndef make_unique_name(base_name):\n    \"\"\"Generate a unique name by appending numbers if needed\"\"\"\n    if not nuke.exists(base_name):\n        return base_name\n    \n    i = 1\n    while nuke.exists(base_name + '_' + str(i)):\n        i += 1\n    return base_name + '_' + str(i)\n\ndef is_copy_node(node):\n    \"\"\"Check if this node is a copy/duplicate\"\"\"\n    return '_copy_' in node.name() or (node.knob('tags') and node\['tags'].value())\n\ndef get_base_name(node_name):\n    \"\"\"Extract base name by removing copy suffixes\"\"\"\n    return node_name.replace('_copy_1', '').replace('_copy_2', '').replace('_copy_3', '')\n\n# Main execution\nn = nuke.thisNode()\n\nif is_copy_node(n):\n    # Handle copied/duplicated nodes\n    base_name = get_base_name(n.name())\n    \n    if not nuke.exists(base_name):\n        # Original name is available\n        n.setName(base_name)\n    else:\n        # Need to make it unique\n        unique_name = make_unique_name(base_name + '_copy')\n        n.setName(unique_name)\nelse:\n    # Handle initial node creation\n    result = nuke.getInput('Create Marker', 'Enter marker name:')\n    \n    if result:\n        # User provided a name\n        clean_user_name = clean_name(result)\n        unique_name = make_unique_name(clean_user_name)\n        n.setName(unique_name)\n    else:\n        # User cancelled - use default naming\n        default_name = make_unique_name('Marker')\n        n.setName(default_name)\n\nn\['onCreate'].setValue('''\nclass ConnectNodeCreator:\n    def __init__(self):\n        self.marker = nuke.thisNode()\n        self.name = self.marker.name()\n        \n    def create_connect(self):\n        import nuke\n        \n        selected = nuke.selectedNodes()\n        \n        # Calculate position for the new Connect node\n        if selected:\n            x = selected\[-1]\[\"xpos\"].value() + 150\n            y = selected\[-1]\[\"ypos\"].value() + 50\n        else:\n            x = self.marker\[\"xpos\"].value() + 150\n            y = self.marker\[\"ypos\"].value() + 50\n        \n        # Create the Group node\n        connect = nuke.createNode(\"Group\", inpanel=False)\n        \n        # Set basic properties\n        connect\[\"xpos\"].setValue(x)\n        connect\[\"ypos\"].setValue(y)\n        connect\[\"tile_color\"].setValue(0x666666ff)\n        connect\[\"label\"].setValue(\"\[value status]\")\n        connect\[\"hide_input\"].setValue(True)\n        \n        # Generate unique name\n        i = 1\n        base_name = \"Connect\"\n        if nuke.exists(base_name):\n            while nuke.exists(base_name + str(i)):\n                i += 1\n            connect.setName(base_name + str(i))\n        else:\n            connect.setName(base_name)\n        \n        # Add the Connect tab\n        connect.addKnob(nuke.Tab_Knob(\"Connect\"))\n        \n        # Add CLASSIFICATION knob (invisible)\n        classification_knob = nuke.String_Knob(\"CLASSIFICATION\", \"\")\n        classification_knob.setValue(\"Connect\")\n        classification_knob.setFlag(nuke.INVISIBLE)\n        connect.addKnob(classification_knob)\n        \n        # Add parent knob\n        parent_knob = nuke.String_Knob(\"parent\", \"parent\", self.name)\n        parent_knob.setTooltip(\"Node name of the Marker to connect to\")\n        connect.addKnob(parent_knob)\n        \n        # Add status knob\n        status_knob = nuke.String_Knob(\"status\", \"Status\", \"Connected to: \" + self.name)\n        status_knob.setTooltip(\"Current connection status\")\n        status_knob.setFlag(nuke.DISABLED)\n        connect.addKnob(status_knob)\n        \n        # Add connectFromIndex button\n        connectFromIndex_code = \"\"\"import nuke\n\ndef show_searchable_marker_selector():\n    # Try to import Qt\n    try:\n        from PySide2 import QtWidgets, QtCore\n        from PySide2.QtCore import Qt\n    except ImportError:\n        try:\n            from PySide import QtGui as QtWidgets\n            from PySide import QtCore\n            from PySide.QtCore import Qt\n        except ImportError:\n            # Fallback to simple choice\n            markers = \[]\n            with nuke.thisParent():\n                for n in nuke.allNodes():\n                    if (hasattr(n, 'knob') and n.knob('CLASSIFICATION') and \n                        n\['CLASSIFICATION'].value() == 'Marker'):\n                        markers.append(n.name())\n            \n            if not markers:\n                nuke.message('No markers found')\n                return None\n            else:\n                choice = nuke.choice('Select Marker', 'Choose marker:', markers)\n                return markers\[choice] if choice is not None else None\n    \n    class SearchableMarkerSelector(QtWidgets.QDialog):\n        def __init__(self, parent=None):\n            super(SearchableMarkerSelector, self).__init__(parent)\n            self.setWindowTitle('Select Marker')\n            self.setModal(True)\n            self.selected_marker = None\n            self.all_markers = \[]\n            self.setupUI()\n            self.populateMarkers()\n            \n        def setupUI(self):\n            layout = QtWidgets.QVBoxLayout()\n            \n            header = QtWidgets.QLabel('Choose a Marker to connect to:')\n            header.setStyleSheet('font-weight: bold; margin-bottom: 5px;')\n            layout.addWidget(header)\n            \n            # Search box\n            search_layout = QtWidgets.QHBoxLayout()\n            search_label = QtWidgets.QLabel('Search:')\n            self.search_box = QtWidgets.QLineEdit()\n            self.search_box.setPlaceholderText('Type to filter markers...')\n            self.search_box.textChanged.connect(self.filterMarkers)\n            search_layout.addWidget(search_label)\n            search_layout.addWidget(self.search_box)\n            layout.addLayout(search_layout)\n            \n            # List widget\n            self.listWidget = QtWidgets.QListWidget()\n            self.listWidget.setMinimumSize(450, 300)\n            layout.addWidget(self.listWidget)\n            \n            # Status label\n            self.status_label = QtWidgets.QLabel('')\n            self.status_label.setStyleSheet('color: #666; font-size: 11px;')\n            layout.addWidget(self.status_label)\n            \n            # Buttons\n            buttonBox = QtWidgets.QDialogButtonBox()\n            self.connectBtn = buttonBox.addButton('Connect', QtWidgets.QDialogButtonBox.AcceptRole)\n            cancelBtn = buttonBox.addButton('Cancel', QtWidgets.QDialogButtonBox.RejectRole)\n            \n            self.connectBtn.setEnabled(False)\n            \n            buttonBox.accepted.connect(self.accept)\n            buttonBox.rejected.connect(self.reject)\n            \n            layout.addWidget(buttonBox)\n            self.setLayout(layout)\n            \n            self.listWidget.itemDoubleClicked.connect(self.accept)\n            self.listWidget.itemSelectionChanged.connect(self.updateConnectButton)\n            \n            self.search_box.setFocus()\n            \n        def populateMarkers(self):\n            self.all_markers = \[]\n            \n            # Search in parent context, not inside the Group\n            with nuke.thisParent():\n                for n in nuke.allNodes():\n                    if (hasattr(n, 'knob') and n.knob('CLASSIFICATION') and \n                        n\['CLASSIFICATION'].value() == 'Marker'):\n                        self.all_markers.append(\{\n                            'node_name': n.name(),\n                            'search_text': n.name().lower()\n                        \})\n            \n            self.all_markers.sort(key=lambda x: x\['node_name'].lower())\n            self.filterMarkers('')\n            \n        def filterMarkers(self, search_text=''):\n            if not hasattr(self, 'search_box'):\n                return\n                \n            search_text = self.search_box.text().lower().strip()\n            self.listWidget.clear()\n            \n            if not self.all_markers:\n                no_markers = QtWidgets.QListWidgetItem('No markers found')\n                no_markers.setFlags(no_markers.flags() & ~Qt.ItemIsSelectable)\n                self.listWidget.addItem(no_markers)\n                self.status_label.setText('No markers available')\n                return\n            \n            if search_text:\n                filtered_markers = \[\n                    marker for marker in self.all_markers \n                    if search_text in marker\['search_text']\n                ]\n            else:\n                filtered_markers = self.all_markers\n            \n            for marker in filtered_markers:\n                item = QtWidgets.QListWidgetItem(marker\['node_name'])\n                item.setData(Qt.UserRole, marker\['node_name'])\n                self.listWidget.addItem(item)\n            \n            total_count = len(self.all_markers)\n            filtered_count = len(filtered_markers)\n            \n            if search_text:\n                if filtered_count == 0:\n                    self.status_label.setText('No matches found (0 of ' + str(total_count) + ' markers)')\n                else:\n                    self.status_label.setText('Showing ' + str(filtered_count) + ' of ' + str(total_count) + ' markers')\n            else:\n                self.status_label.setText(str(total_count) + ' markers available')\n            \n            if self.listWidget.count() > 0 and filtered_markers:\n                self.listWidget.setCurrentRow(0)\n                \n        def updateConnectButton(self):\n            current_item = self.listWidget.currentItem()\n            has_valid_selection = (current_item and \n                                 current_item.data(Qt.UserRole) is not None)\n            self.connectBtn.setEnabled(has_valid_selection)\n            \n        def keyPressEvent(self, event):\n            if event.key() == Qt.Key_Return or event.key() == Qt.Key_Enter:\n                if self.connectBtn.isEnabled():\n                    self.accept()\n                return\n            elif event.key() == Qt.Key_Escape:\n                self.reject()\n                return\n            elif event.key() == Qt.Key_Down:\n                if self.search_box.hasFocus() and self.listWidget.count() > 0:\n                    self.listWidget.setFocus()\n                    self.listWidget.setCurrentRow(0)\n                    return\n            elif event.key() == Qt.Key_Up:\n                if self.listWidget.hasFocus() and self.listWidget.currentRow() == 0:\n                    self.search_box.setFocus()\n                    return\n                    \n            super(SearchableMarkerSelector, self).keyPressEvent(event)\n            \n        def accept(self):\n            current_item = self.listWidget.currentItem()\n            if current_item and current_item.data(Qt.UserRole):\n                self.selected_marker = current_item.data(Qt.UserRole)\n            super(SearchableMarkerSelector, self).accept()\n    \n    try:\n        app = QtWidgets.QApplication.instance()\n        parent = None\n        if app:\n            for widget in app.topLevelWidgets():\n                if widget.metaObject().className() == 'Foundry::UI':\n                    parent = widget\n                    break\n        \n        dialog = SearchableMarkerSelector(parent)\n        if dialog.exec_():\n            return dialog.selected_marker\n        return None\n        \n    except Exception as e:\n        nuke.message('Error creating dialog: ' + str(e))\n        return None\n\n# Execute\nconnect_node = nuke.thisNode()\nselected_marker = show_searchable_marker_selector()\nif selected_marker:\n    connect_node\['parent'].setValue(selected_marker)\"\"\"\n        \n        connectFromIndex_knob = nuke.PyScript_Knob(\"connectFromIndex\", \"connect from index\", connectFromIndex_code)\n        connectFromIndex_knob.setTooltip(\"Show popup to select from available markers\")\n        connectFromIndex_knob.setFlag(nuke.STARTLINE)\n        connect.addKnob(connectFromIndex_knob)\n        \n        # Add reconnect button\n        reconnect_code = \"\"\"import nuke\nn = nuke.thisNode()\ntarget = n\['parent'].value()\n\nif not target:\n    nuke.message('No target marker set')\nelse:\n    with nuke.thisParent():\n        node = nuke.toNode(target)\n        if node:\n            n.setInput(0, node)\n            nuke.message('Reconnected to: ' + target)\n        else:\n            nuke.message('Target not found: ' + target)\"\"\"\n        \n        reconnect_knob = nuke.PyScript_Knob(\"reconnect\", \"reconnect\", reconnect_code)\n        reconnect_knob.setTooltip(\"Force reconnection to target marker\")\n        reconnect_knob.clearFlag(nuke.STARTLINE)\n        connect.addKnob(reconnect_knob)\n        \n        # Add findParent button\n        findParent_code = \"\"\"import nuke\nn = nuke.thisNode()\ntarget = n\['parent'].value()\n\nif not target:\n    nuke.message('No target marker set')\nelse:\n    with nuke.thisParent():\n        node = nuke.toNode(target)\n        if node:\n            nuke.zoom(2, \[node.xpos() + node.screenWidth()//2, \n                         node.ypos() + node.screenHeight()//2])\n        else:\n            nuke.message('Target not found: ' + target)\"\"\"\n        \n        findParent_knob = nuke.PyScript_Knob(\"findParent\", \"find parent\", findParent_code)\n        findParent_knob.setTooltip(\"Locate and zoom to the target marker\")\n        findParent_knob.clearFlag(nuke.STARTLINE)\n        connect.addKnob(findParent_knob)\n        \n        # Add Utilities tab\n        connect.addKnob(nuke.Tab_Knob(\"utilities\", \"Utilities\"))\n        \n        # Add findConnected button\n        findConnected_code = \"\"\"import nuke\nconnect_node = nuke.thisNode()\nparent_name = connect_node\['parent'].value()\n\nprint('=== DEBUG Find Connected ===')\nprint('Current Connect node: ' + connect_node.name())\nprint('Parent name: \"' + str(parent_name) + '\"')\n\nif not parent_name:\n    nuke.message('No parent marker set')\nelse:\n    # Search in parent context, not inside the Group!\n    with nuke.thisParent():\n        # Deselect all\n        for n in nuke.allNodes():\n            n.setSelected(False)\n        \n        found = 0\n        print('Checking all nodes in parent context...')\n        \n        for n in nuke.allNodes():\n            node_name = n.name()\n            \n            # Check if it has parent knob\n            if hasattr(n, 'knob') and n.knob('parent'):\n                try:\n                    node_parent = n\['parent'].value()\n                    print('Node: ' + node_name + ' -> parent: \"' + str(node_parent) + '\"')\n                    \n                    if node_parent == parent_name and n.name() != connect_node.name():\n                        print('  -> MATCH! Selecting ' + node_name)\n                        n.setSelected(True)\n                        found += 1\n                    elif node_parent == parent_name:\n                        print('  -> Match but skipping self: ' + node_name)\n                    else:\n                        print('  -> No match')\n                except Exception as e:\n                    print('  -> Error reading parent: ' + str(e))\n            else:\n                print('Node: ' + node_name + ' -> No parent knob')\n        \n        print('=== DEBUG SUMMARY ===')\n        print('Total found: ' + str(found))\n        print('=====================')\n        \n        if found:\n            nuke.message('Selected ' + str(found) + ' Connect nodes targeting: ' + parent_name)\n        else:\n            nuke.message('No other Connect nodes found targeting: ' + parent_name)\"\"\"\n        \n        findConnected_knob = nuke.PyScript_Knob(\"findConnected\", \"find connected\", findConnected_code)\n        findConnected_knob.setTooltip(\"Select all Connect nodes that reference the same parent Marker\")\n        findConnected_knob.setFlag(nuke.STARTLINE)\n        connect.addKnob(findConnected_knob)\n        \n        # Add hideInputToggle button\n        hideInputToggle_code = \"\"\"import nuke\n\ndef hideInputToggle():\n    node = nuke.thisNode()\n    knob = node.knob('hideInputToggle')\n    hide_input_knob = node.knob('hide_input')\n    \n    if hide_input_knob is not None:\n        # Toggle the actual hide_input value\n        current_value = hide_input_knob.value()\n        hide_input_knob.setValue(not current_value)\n        \n        # Update button label based on new state\n        if hide_input_knob.value():\n            knob.setLabel('show input')\n        else:\n            knob.setLabel('hide input')\n\n# Run the function\nhideInputToggle()\"\"\"\n        \n        hideInputToggle_knob = nuke.PyScript_Knob(\"hideInputToggle\", \"show input\", hideInputToggle_code)\n        hideInputToggle_knob.setTooltip(\"Toggle input visibility\")\n        hideInputToggle_knob.clearFlag(nuke.STARTLINE)\n        connect.addKnob(hideInputToggle_knob)\n        \n        # Add togglePostageStamp button\n        togglePostageStamp_code = \"\"\"import nuke\n\ndef togglePostageStamp():\n    node = nuke.thisNode()\n    knob = node.knob('togglePostageStamp')\n    postage_knob = node.knob('postage_stamp')\n    \n    if postage_knob is not None:\n        # Toggle the actual postage_stamp value\n        current_value = postage_knob.value()\n        postage_knob.setValue(not current_value)\n        \n        # Update button label based on new state\n        if postage_knob.value():\n            knob.setLabel('hide stamp')\n        else:\n            knob.setLabel('show stamp')\n\n# Run the function\ntogglePostageStamp()\"\"\"\n        \n        togglePostageStamp_knob = nuke.PyScript_Knob(\"togglePostageStamp\", \"show stamp\", togglePostageStamp_code)\n        togglePostageStamp_knob.setTooltip(\"Toggle postage stamp visibility\")\n        togglePostageStamp_knob.clearFlag(nuke.STARTLINE)\n        connect.addKnob(togglePostageStamp_knob)\n        \n        # Add Info tab\n        connect.addKnob(nuke.Tab_Knob(\"info\", \"Info\"))\n        \n        # Add version text\n        version_knob = nuke.Text_Knob(\"version\", \"\", '<font size=\"5\">Connect</font><font color=#777777> v1.2</font>')\n        version_knob.setFlag(nuke.STARTLINE)\n        connect.addKnob(version_knob)\n        \n        # Add empty line\n        connect.addKnob(nuke.Text_Knob(\"\", \"\"))\n        \n        # Add description\n        description_text = \"\"\"<strong>•</strong> <b>Connect nodes</b> act as reference points<br>that link back to this marker\n<br><i><br>\n<strong>•</strong> Set the \"parent\" field to the target marker<br>name, then use \"Connect\"\n<br>\n<strong>•</strong> Provides quick navigation and organization<br>in complex node graphs<br> \n<strong>•</strong> Maintains visual connection without affecting<br>the actual node flow<br><br>\n<b><a href=\"https://johntothvfx.com\" style=\"color:#777777;\">John Toth © 2022</a></b><br>\"\"\"\n        \n        description_knob = nuke.Text_Knob(\"description\", \"\", description_text)\n        description_knob.setFlag(nuke.STARTLINE)\n        connect.addKnob(description_knob)\n        \n        # Add empty line\n        connect.addKnob(nuke.Text_Knob(\"\", \"\"))\n        \n        # Add demo button (invisible)\n        demo_knob = nuke.PyScript_Knob(\"demo\", '<a href=\"https://johntothvfx.com\"><span style=\"color:#777777\">Tool Demo</span></a>', 'nuke.message(\"coming soon\")')\n        demo_knob.setTooltip(\"Launches the web page where it will have more documentation or a video about the node.\")\n        demo_knob.setFlag(nuke.INVISIBLE)\n        demo_knob.setFlag(nuke.STARTLINE)\n        connect.addKnob(demo_knob)\n        \n        # Add version log button\n        log_code = \"\"\"\nversion_number = \"1.2.1\"\ncontext = \"Other/Connect\"\nmodified_date = \"5th June 2025\"\ndeveloper = \"John Toth © 2022\"\nsite = \"<a href='website linke here'><span style='color:#BBBBBB'>\"\nlog = \\\\\\\"\\\\\\\"\\\\\\\"\n<br></i><b> v 1.0 </b><i>\n- connects the input of the node based on the parent\n<br></i><b> v 1.1 </b><i>\n- index list was added to keep an list of all connect nodes to speed up workflow.\n<br></i><b> v 1.2 </b><i>\n- index now works through a difference system that works more dynamically\n- marker system implementation has been added\n- cleaner interface\n\\\\\\\"\\\\\\\"\\\\\\\"\nthank_you = \" Special thanks to Samantha Maiolo for earlier development for this tool\"\n\n# Retrieve node name\nname = nuke.thisNode()\['CLASSIFICATION'].getValue()\n\n# Message components\nheader = \"Version Log:\"\ndlm = \"<b>Date Last Modified: </b>\" + modified_date\nspace = \" \"\nenter = \"<br><br>\"\nupper = \"<b>\"\nlower = \"</b>\"\n\n# Formatted message using string concatenation to avoid f-string conflicts\nmessage = (\n    upper + header + enter +\n    \"Name: \" + lower + name + \"<br>\" +\n    upper + \"Version Number: \" + lower + version_number + \"<br>\" +\n    upper + \"Context: \" + lower + context + enter +\n    dlm + log + \"<br>\" +\n    \"<b>Thank You:</b><br>\" + thank_you + \"<br>\" + enter +\n    \"</i>\" + upper + site + developer + lower + \"</span></a>\"\n)\n\n# Display the message\nnuke.message(message)\"\"\"\n        \n        log_knob = nuke.PyScript_Knob(\"log\", '<a href=\"https://johntothvfx.com\"><span style=\"color:#777777\">Version Log</span></a>', log_code)\n        log_knob.setTooltip('Contains information about this node.\\\\n\\\\n- classification\\\\n- context\\\\n- date last modified\\\\n- developer notes\\\\n- version number\\\\n- version log\\\\n- year made')\n        log_knob.clearFlag(nuke.STARTLINE)\n        connect.addKnob(log_knob)\n        \n        # Set the onCreate code\n        onCreate_code = \"\"\"import nuke\n# Set unique name\ni = 1\nwhile nuke.exists('Connect_' + str(i)):\n    i += 1\nnuke.thisNode().setName('Connect_' + str(i))\n# Try auto-reconnect if targetMarker is set\nn = nuke.thisNode()\nif n.knob('parent') and n\['parent'].value():\n    target = n\['parent'].value()\n    with nuke.thisParent():\n        node = nuke.toNode(target)\n        if node:\n            n.setInput(0, node)\"\"\"\n        \n        connect\[\"onCreate\"].setValue(onCreate_code)\n        \n        # Set the knobChanged code\n        knobChanged_code = \"\"\"import nuke\nn = nuke.thisNode()\nk = nuke.thisKnob()\n\nif k.name() == 'parent':\n    target = n\['parent'].value()\n    if target:\n        with nuke.thisParent():\n            node = nuke.toNode(target)\n            if node:\n                n.setInput(0, node)\n                n\['status'].setValue('Connected to: ' + target)\n                n\['tile_color'].setValue(0x4a90e2ff)\n            else:\n                n\['status'].setValue('ERROR: ' + target + ' not found')\n                n\['tile_color'].setValue(0xff4444ff)\n    else:\n        n.setInput(0, None)\n        n\['status'].setValue('No Parent Set')\n        n\['tile_color'].setValue(0x666666ff)\n\nelif k.name() == 'inputChange':\n    target = n\['parent'].value()\n    input_node = n.input(0)\n    \n    if not input_node:\n        n\['tile_color'].setValue(0xff4444ff)\n        if target:\n            n\['status'].setValue('Disconnected from: ' + target)\n        else:\n            n\['status'].setValue('No connection')\n    elif target and input_node.name() == target:\n        n\['tile_color'].setValue(0x4a90e2ff)\n        n\['status'].setValue('(' + target + ')')\n    else:\n        n\['tile_color'].setValue(0xffa500ff)\n        if input_node:\n            n\['status'].setValue('Wrong connection: ' + input_node.name())\n        else:\n            n\['status'].setValue('Connection mismatch')\"\"\"\n        \n        connect\[\"knobChanged\"].setValue(knobChanged_code)\n        \n        # Create internal Input and Output nodes\n        connect.begin()\n        input_node = nuke.createNode(\"Input\", inpanel=False)\n        input_node\[\"xpos\"].setValue(0)\n        input_node\[\"ypos\"].setValue(-200)\n        input_node\[\"label\"].setValue(\"\[value number]\")\n        output_node = nuke.createNode(\"Output\", inpanel=False)\n        output_node\[\"xpos\"].setValue(0)\n        output_node\[\"ypos\"].setValue(-100)\n        connect.end()\n        \n        # Connect the group to the marker\n        connect.setInput(0, self.marker)\n        \n        # Select the new Connect node\n        for n in nuke.allNodes():\n            n.setSelected(False)\n        connect.setSelected(True)\n        \n        nuke.message(\"Created Connect node: \" + connect.name())\n\ndef create_connect():\n    creator = ConnectNodeCreator()\n    creator.create_connect()\n''')"
 tile_color 0x777777ff
 selected true
 addUserKnob {20 Marker}
 addUserKnob {1 CLASSIFICATION +INVISIBLE}
 CLASSIFICATION Marker
 addUserKnob {1 output +INVISIBLE}
 output "\[knob tile_color \[value presets]]\[value knob.tags]"
 addUserKnob {4 presets M {"2004318207\tMarker" "0\tRead" "24576\tDeep" "1908830719\tRoto/Paint" "2654757887\tChannel" "2617245696\t3D / Scanline" "16711935\tkeyer" "2963561983\tTime" "3165597183\tWrite" "1993542655\tSTMap" "3241845759\tDev" "3448063\tCustom 001" "782318079\tCustom 002" "" "" "" "" ""} t "Choose a preset label and its associated color value"}
 addUserKnob {1 tags l Tags t "Comma-separated tags for organization"}
 addUserKnob {22 rename l "   rename   " t "Rename this marker" T "import nuke\nn = nuke.thisNode()\nold = n.name()\nresult = nuke.getInput('Rename', 'New name (' + old + '):')\nif result and result != old:\n    clean = result.replace(' ', '_')\n    if not nuke.exists(clean):\n        n.setName(clean)\n        # Update any Connect nodes\n        for node in nuke.allNodes():\n            if (hasattr(node, 'knob') and node.knob('targetMarker') and \n                node\['targetMarker'].value() == old):\n                node\['targetMarker'].setValue(clean)\n        nuke.message('Renamed to: ' + clean)\n    else:\n        nuke.message('Name already exists')" +STARTLINE}
 addUserKnob {20 connect l Connect}
 addUserKnob {22 createConnect l "create connect" t "Create and link a Connect node to this marker" T "exec(nuke.thisNode()['onCreate'].value())\ncreator = ConnectNodeCreator()\ncreator.create_connect()" +STARTLINE}
 addUserKnob {22 selectConnects l "select connected" t "Select all Connect nodes referencing this marker" -STARTLINE T "marker = nuke.thisNode()\nname = marker.name()\nfor n in nuke.allNodes():\n    n.setSelected(False)\nfound = 0\nfor n in nuke.allNodes():\n    if (hasattr(n, 'knob') and n.knob('parent') and\n        n\['parent'].value() == name):\n        n.setSelected(True)\n        found += 1\nif found:\n    nuke.message('Selected ' + str(found) + ' Connect nodes')\nelse:\n    nuke.message('No Connect nodes found')"}
 addUserKnob {22 reconnectAll l "reconnect all" t "Update all Connect node indexes" -STARTLINE T "markers = \[]\nfor n in nuke.allNodes():\n    if (hasattr(n, 'knob') and n.knob('CLASSIFICATION') and\n        n\['CLASSIFICATION'].value() == 'Marker'):\n        markers.append(n.name())\n\nmarkers.sort()\nupdated_count = 0\nskipped_count = 0\n\nfor n in nuke.allNodes():\n    if (hasattr(n, 'knob') and n.knob('CLASSIFICATION') and\n        n\['CLASSIFICATION'].value() == 'Connect'):\n        \n        # Check current state\n        parent_knob = n.knob('parent')\n        input_node = n.input(0)\n        \n        if parent_knob:\n            parent_value = parent_knob.value()\n            \n            # Check if properly connected\n            if input_node and parent_value == input_node.name():\n                skipped_count += 1\n                continue\n            \n            # Try to connect if parent is set but not connected\n            if parent_value:\n                target_node = nuke.toNode(parent_value)\n                if target_node:\n                    n.setInput(0, target_node)\n                    updated_count += 1\n\nnuke.message('Connected ' + str(updated_count) + ' Connect nodes')"}
 addUserKnob {20 info l Info}
 addUserKnob {26 version l "" +STARTLINE T "<font size=\"5\">Marker</font><font color=#777777> v1.0</font>"}
 addUserKnob {26 ""}
 addUserKnob {26 description l "" +STARTLINE T "<strong>•</strong> <b>Marker</b> act as reference anchors/bookmark<br>for organizing complex node graphs\n<br><i><br>\n<strong>•</strong> Create Connect nodes to link back to<br>this marker from anywhere in your comp\n<br>\n<strong>•</strong> Essential for navigation in large<br>node networks and complex workflows<br> \n<strong>•</strong> Use \"Create Connect\" to generate reference<br>nodes that maintain visual organization<br><br>\n<b><a href=\"https://johntothvfx.com\" style=\"color:#777777;\">John Toth © 2024</a></b><br>"}
 addUserKnob {26 ""}
 addUserKnob {22 demo l "<a href=\"https://johntothvfx.com\"><span style=\"color:#777777\">Tool Demo</span></a>" t "Launches the web page where it will have more documentation or a video about the node." +INVISIBLE T "nuke.message(\"coming soon\")" +STARTLINE}
 addUserKnob {22 log l "<a href=\"https://johntothvfx.com\"><span style=\"color:#777777\">Version Log</span></a>" t "Contains information about this node.\n\n- classification\n- context\n- date last modified\n- developer notes\n- version number\n- version log\n- year made" -STARTLINE T "\nversion_number = \"1.0.0\"\ncontext = \"Other/Marker\"\nmodified_date = \"5th June 2025\"\ndeveloper = \"John Toth © 2024\"\nsite = \"<a href='website linke here'><span style='color:#BBBBBB'>\"\nlog = \"\"\"\n<br></i><b> v 1.0 </b><i>\n- connects the input of the node based on the parent\n\"\"\"\nthank_you = \" Special thanks to Samantha Maiolo for earlier development for this tool\"\n\n# Retrieve node name\nname = nuke.thisNode()\['CLASSIFICATION'].getValue()\n\n# Message components\nheader = \"Version Log:\"\ndlm = \"<b>Date Last Modified: </b>\" + modified_date\nspace = \" \"\nenter = \"<br><br>\"\nupper = \"<b>\"\nlower = \"</b>\"\n\n# Formatted message\nmessage = (\n    f\"\{upper\}\{header\}\{enter\}\"\n    f\"Name: \{lower\}\{name\}<br>\"\n    f\"\{upper\}Version Number: \{lower\}\{version_number\}<br>\"\n    f\"\{upper\}Context: \{lower\}\{context\}\{enter\}\"\n    f\"\{dlm\}\{log\}<br>\"\n    f\"<b>Thank You:</b><br>\{thank_you\}<br>\{enter\}\"\n    f\"</i>\{upper\}\{site\}\{developer\}\{lower\}</span></a>\"\n)\n\n# Display the message\nnuke.message(message)"}
}
