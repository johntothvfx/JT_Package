set cut_paste_input [stack 0]
version 15.1 v4
push $cut_paste_input
NoOp {
 name camera1
 onCreate "import nuke\n\nclass MarkerNode:\n    def __init__(self, node):\n        self.node = node\n        self.setup_marker()\n    \n    def setup_marker(self):\n        # Only add knobs if they don't already exist\n        if not self.node.knob('CLASSIFICATION'):\n            self.add_marker_knobs()\n            self.add_connect_knobs()\n            self.add_info_knobs()\n        \n        # Handle naming logic\n        self.handle_naming()\n    \n    def add_marker_knobs(self):\n        n = self.node\n        \n        # Add the Marker tab\n        n.addKnob(nuke.Tab_Knob('Marker'))\n        \n        # Add CLASSIFICATION knob (invisible)\n        classification_knob = nuke.String_Knob('CLASSIFICATION', '')\n        classification_knob.setValue('Marker')\n        classification_knob.setFlag(nuke.INVISIBLE)\n        n.addKnob(classification_knob)\n        \n        # Add output knob (invisible)\n        output_knob = nuke.String_Knob('output', '')\n        output_knob.setValue('\[knob tile_color \[value presets]]\[value knob.tags]')\n        output_knob.setFlag(nuke.INVISIBLE)\n        n.addKnob(output_knob)\n        \n        # Add presets dropdown\n        presets_knob = nuke.Enumeration_Knob('presets', '', \[\n            '2004318207\\tmarker', '0\\tRead', '24576\\tDeep', '1908830719\\tRoto/Paint',\n            '2654757887\\tChannel', '2617245696\\t3D / Scanline', '16711935\\tkeyer',\n            '2963561983\\tTime', '3165597183\\tWrite', '1993542655\\tSTMap',\n            '3241845759\\tDev', '3448063\\tCustom 001', '782318079\\tCustom 002 ',\n            '', '', '', '', ''\n        ])\n        n.addKnob(presets_knob)\n        \n        # Add tags knob\n        tags_knob = nuke.String_Knob('tags', 'Tags', '')\n        tags_knob.setTooltip('Comma-separated tags for organization')\n        n.addKnob(tags_knob)\n        \n        # Add rename button\n        rename_knob = nuke.PyScript_Knob('rename', '   rename   ', self.get_rename_code())\n        rename_knob.setTooltip('Rename this marker')\n        rename_knob.setFlag(nuke.STARTLINE)\n        n.addKnob(rename_knob)\n    \n    def add_connect_knobs(self):\n        n = self.node\n        \n        # Add Connect tab\n        n.addKnob(nuke.Tab_Knob('connect', 'Connect'))\n        \n        # Add create connect button - calling function directly for speed\n        createConnect_knob = nuke.PyScript_Knob('createConnect', 'create connect', 'self.create_connect_node()')\n        n.addKnob(createConnect_knob)\n        \n        # Add select connects button\n        selectConnects_knob = nuke.PyScript_Knob('selectConnects', 'select connected', self.get_select_connects_code())\n        selectConnects_knob.setTooltip('Select all Connect nodes referencing this marker')\n        selectConnects_knob.clearFlag(nuke.STARTLINE)\n        n.addKnob(selectConnects_knob)\n        \n        # Add reconnect all button\n        reconnectAll_knob = nuke.PyScript_Knob('reconnectAll', 'reconnect all', self.get_reconnect_all_code())\n        reconnectAll_knob.setTooltip('Update all Connect node indexes')\n        reconnectAll_knob.clearFlag(nuke.STARTLINE)\n        n.addKnob(reconnectAll_knob)\n    \n    def add_info_knobs(self):\n        n = self.node\n        \n        # Add Info tab\n        n.addKnob(nuke.Tab_Knob('info', 'Info'))\n        \n        # Add version text\n        version_knob = nuke.Text_Knob('version', '', '<font size=\"5\">Marker</font><font color=#777777> v1.0</font>')\n        version_knob.setFlag(nuke.STARTLINE)\n        n.addKnob(version_knob)\n        \n        # Add empty line\n        n.addKnob(nuke.Text_Knob('', ''))\n        \n        # Add description - using simple characters\n        description_text = '<b>Marker nodes</b> act as reference anchors for organizing complex node graphs<br><br>Create Connect nodes to link back to this marker from anywhere in your comp<br><br>Essential for navigation in large node networks and complex workflows<br><br>Use \"Create Connect\" to generate reference nodes that maintain visual organization<br><br><b><a href=\"https://johntothvfx.com\" style=\"color:#777777;\">John Toth 2024</a></b>'\n        \n        description_knob = nuke.Text_Knob('description', '', description_text)\n        description_knob.setFlag(nuke.STARTLINE)\n        n.addKnob(description_knob)\n        \n        # Add empty line\n        n.addKnob(nuke.Text_Knob('', ''))\n        \n        # Add demo and log buttons\n        demo_knob = nuke.PyScript_Knob('demo', 'Tool Demo', 'nuke.message(\"coming soon\")')\n        demo_knob.setTooltip('Launches the web page where it will have more documentation or a video about the node.')\n        demo_knob.setFlag(nuke.INVISIBLE)\n        demo_knob.setFlag(nuke.STARTLINE)\n        n.addKnob(demo_knob)\n        \n        log_knob = nuke.PyScript_Knob('log', 'Version Log', self.get_log_code())\n        log_knob.setTooltip('Contains information about this node.')\n        log_knob.clearFlag(nuke.STARTLINE)\n        n.addKnob(log_knob)\n    \n    def create_connect_node(self):\n        \"\"\"Direct function call for creating Connect node - much faster!\"\"\"\n        marker = self.node\n        name = marker.name()\n        selected = nuke.selectedNodes()\n\n        if selected:\n            x = selected\[-1]\['xpos'].value() + 150\n            y = selected\[-1]\['ypos'].value() + 50\n        else:\n            x = marker\['xpos'].value() + 150\n            y = marker\['ypos'].value() + 50\n\n        connect = nuke.createNode('Group', inpanel=False)\n        connect\['xpos'].setValue(x)\n        connect\['ypos'].setValue(y)\n        connect\['tile_color'].setValue(0x666666ff)\n        connect\['label'].setValue('\[value status]')\n        connect\['hide_input'].setValue(True)\n\n        i = 1\n        base_name = 'Connect'\n        if nuke.exists(base_name):\n            while nuke.exists(base_name + str(i)):\n                i += 1\n            connect.setName(base_name + str(i))\n        else:\n            connect.setName(base_name)\n\n        connect.addKnob(nuke.Tab_Knob('Connect'))\n\n        classification_knob = nuke.String_Knob('CLASSIFICATION', '')\n        classification_knob.setValue('Connect')\n        classification_knob.setFlag(nuke.INVISIBLE)\n        connect.addKnob(classification_knob)\n\n        parent_knob = nuke.String_Knob('parent', 'parent', name)\n        parent_knob.setTooltip('Node name of the Marker to connect to')\n        connect.addKnob(parent_knob)\n\n        status_knob = nuke.String_Knob('status', 'Status', 'Connected to: ' + name)\n        status_knob.setTooltip('Current connection status')\n        status_knob.setFlag(nuke.DISABLED)\n        connect.addKnob(status_knob)\n\n        # Add basic buttons\n        reconnect_code = \"import nuke\\nn = nuke.thisNode()\\ntarget = n\['parent'].value()\\nif not target:\\n    nuke.message('No target marker set')\\nelse:\\n    with nuke.thisParent():\\n        node = nuke.toNode(target)\\n        if node:\\n            n.setInput(0, node)\\n            nuke.message('Reconnected to: ' + target)\\n        else:\\n            nuke.message('Target not found: ' + target)\"\n\n        reconnect_knob = nuke.PyScript_Knob('reconnect', 'reconnect', reconnect_code)\n        reconnect_knob.setTooltip('Force reconnection to target marker')\n        reconnect_knob.setFlag(nuke.STARTLINE)\n        connect.addKnob(reconnect_knob)\n\n        findParent_code = \"import nuke\\nn = nuke.thisNode()\\ntarget = n\['parent'].value()\\nif not target:\\n    nuke.message('No target marker set')\\nelse:\\n    with nuke.thisParent():\\n        node = nuke.toNode(target)\\n        if node:\\n            nuke.zoom(2, \[node.xpos() + 75, node.ypos() + 37])\\n        else:\\n            nuke.message('Target not found: ' + target)\"\n\n        findParent_knob = nuke.PyScript_Knob('findParent', 'find parent', findParent_code)\n        findParent_knob.setTooltip('Locate and zoom to the target marker')\n        findParent_knob.clearFlag(nuke.STARTLINE)\n        connect.addKnob(findParent_knob)\n\n        # Set callbacks\n        onCreate_code = \"import nuke\\ni = 1\\nwhile nuke.exists('Connect' + str(i)):\\n    i += 1\\nnuke.thisNode().setName('Connect' + str(i))\\nn = nuke.thisNode()\\nif n.knob('parent') and n\['parent'].value():\\n    target = n\['parent'].value()\\n    with nuke.thisParent():\\n        node = nuke.toNode(target)\\n        if node:\\n            n.setInput(0, node)\"\n\n        connect\['onCreate'].setValue(onCreate_code)\n\n        knobChanged_code = \"import nuke\\nn = nuke.thisNode()\\nk = nuke.thisKnob()\\nif k.name() == 'parent':\\n    target = n\['parent'].value()\\n    if target:\\n        with nuke.thisParent():\\n            node = nuke.toNode(target)\\n            if node:\\n                n.setInput(0, node)\\n                n\['status'].setValue('Connected to: ' + target)\\n                n\['tile_color'].setValue(0x4a90e2ff)\\n            else:\\n                n\['status'].setValue('ERROR: ' + target + ' not found')\\n                n\['tile_color'].setValue(0xff4444ff)\\n    else:\\n        n.setInput(0, None)\\n        n\['status'].setValue('No Parent Set')\\n        n\['tile_color'].setValue(0x666666ff)\"\n\n        connect\['knobChanged'].setValue(knobChanged_code)\n\n        # Create internal nodes\n        connect.begin()\n        input_node = nuke.createNode('Input', inpanel=False)\n        input_node\['xpos'].setValue(0)\n        input_node\['ypos'].setValue(-200)\n        output_node = nuke.createNode('Output', inpanel=False)\n        output_node\['xpos'].setValue(0)\n        output_node\['ypos'].setValue(-100)\n        connect.end()\n\n        connect.setInput(0, marker)\n        for n in nuke.allNodes():\n            n.setSelected(False)\n        connect.setSelected(True)\n\n        nuke.message('Created Connect node: ' + connect.name())\n    \n    def handle_naming(self):\n        n = self.node\n        \n        # Check if this is initial creation or a duplicate/copy\n        if '_copy_' in n.name() or (n.knob('tags') and n\['tags'].value()):\n            # This is a copy/duplicate - handle naming\n            current_name = n.name().replace('_copy_1', '').replace('_copy_2', '').replace('_copy_3', '')\n\n            # If the current name doesn't exist, keep it as is\n            if not nuke.exists(current_name):\n                n.setName(current_name)\n            else:\n                # Name exists - make it unique\n                i = 1\n                while nuke.exists(current_name + '_copy_' + str(i)):\n                    i += 1\n                n.setName(current_name + '_copy_' + str(i))\n            \n            # Clear onCreate and set new code for future copies\n            conflict_code = \"\"\"import nuke\n\nn = nuke.thisNode()\ncurrent_name = n.name()\n\n# Check if another node has the same name\nall_nodes = nuke.allNodes()\nconflicting_nodes = \[node for node in all_nodes if node.name() == current_name and node != n]\n\nif conflicting_nodes:\n    result = nuke.getInput('Name Conflict', 'Another node named \"' + current_name + '\" exists. Enter new name:')\n    if result:\n        clean = result.replace(' ', '_').replace('-', '_')\n        # Make unique\n        if nuke.exists(clean):\n            i = 1\n            while nuke.exists(clean + '_' + str(i)):\n                i += 1\n            clean = clean + '_' + str(i)\n        n.setName(clean)\n    else:\n        # User cancelled - make it unique automatically\n        i = 1\n        while nuke.exists(current_name + '_' + str(i)):\n            i += 1\n        n.setName(current_name + '_' + str(i))\n\"\"\"\n            n\['onCreate'].setValue(conflict_code)\n\n        else:\n            # Initial creation - show naming popup\n            result = nuke.getInput('Create Marker', 'Enter marker name:')\n            if result:\n                clean = result.replace(' ', '_').replace('-', '_')\n                # Simple uniqueness check\n                if nuke.exists(clean):\n                    i = 1\n                    while nuke.exists(clean + '_' + str(i)):\n                        i += 1\n                    clean = clean + '_' + str(i)\n                n.setName(clean)\n            else:\n                # User cancelled - use default\n                i = 1\n                while nuke.exists('Marker_' + str(i)):\n                    i += 1\n                n.setName('Marker_' + str(i))\n            \n            # Clear onCreate and set new code for future copies\n            conflict_code = \"\"\"import nuke\n\nn = nuke.thisNode()\ncurrent_name = n.name()\n\n# Check if another node has the same name\nall_nodes = nuke.allNodes()\nconflicting_nodes = \[node for node in all_nodes if node.name() == current_name and node != n]\n\nif conflicting_nodes:\n    result = nuke.getInput('Name Conflict', 'Another node named \"' + current_name + '\" exists. Enter new name:')\n    if result:\n        clean = result.replace(' ', '_').replace('-', '_')\n        # Make unique\n        if nuke.exists(clean):\n            i = 1\n            while nuke.exists(clean + '_' + str(i)):\n                i += 1\n            clean = clean + '_' + str(i)\n        n.setName(clean)\n    else:\n        # User cancelled - make it unique automatically\n        i = 1\n        while nuke.exists(current_name + '_' + str(i)):\n            i += 1\n        n.setName(current_name + '_' + str(i))\n\"\"\"\n            n\['onCreate'].setValue(conflict_code)\n    \n    def get_rename_code(self):\n        return 'import nuke\\nn = nuke.thisNode()\\nold = n.name()\\nresult = nuke.getInput(\"Rename\", \"New name (\" + old + \"):\")\\nif result and result != old:\\n    clean = result.replace(\" \", \"_\")\\n    if not nuke.exists(clean):\\n        n.setName(clean)\\n        for node in nuke.allNodes():\\n            if (hasattr(node, \"knob\") and node.knob(\"targetMarker\") and node\[\"targetMarker\"].value() == old):\\n                node\[\"targetMarker\"].setValue(clean)\\n        nuke.message(\"Renamed to: \" + clean)\\n    else:\\n        nuke.message(\"Name already exists\")'\n    \n    def get_select_connects_code(self):\n        return 'marker = nuke.thisNode()\\nname = marker.name()\\nfor n in nuke.allNodes():\\n    n.setSelected(False)\\nfound = 0\\nfor n in nuke.allNodes():\\n    if (hasattr(n, \"knob\") and n.knob(\"parent\") and n\[\"parent\"].value() == name):\\n        n.setSelected(True)\\n        found += 1\\nif found:\\n    nuke.message(\"Selected \" + str(found) + \" Connect nodes\")\\nelse:\\n    nuke.message(\"No Connect nodes found\")'\n    \n    def get_reconnect_all_code(self):\n        return 'updated_count = 0\\nfor n in nuke.allNodes():\\n    if (hasattr(n, \"knob\") and n.knob(\"CLASSIFICATION\") and n\[\"CLASSIFICATION\"].value() == \"Connect\"):\\n        parent_knob = n.knob(\"parent\")\\n        if parent_knob and parent_knob.value():\\n            target_node = nuke.toNode(parent_knob.value())\\n            if target_node:\\n                n.setInput(0, target_node)\\n                updated_count += 1\\nnuke.message(\"Connected \" + str(updated_count) + \" Connect nodes\")'\n    \n    def get_log_code(self):\n        return 'version_number = \"1.0.0\"\\ncontext = \"Other/Marker\"\\nmodified_date = \"5th June 2025\"\\ndeveloper = \"John Toth 2024\"\\nmessage = \"Version Log: Marker v\" + version_number + \" - \" + modified_date + \" - \" + developer\\nnuke.message(message)'\n\n# Initialize the marker\nMarkerNode(nuke.thisNode())"
 tile_color 0x777777ff
 selected true
 xpos 620
 ypos 299
 addUserKnob {20 Marker}
 addUserKnob {1 CLASSIFICATION +INVISIBLE}
 CLASSIFICATION Marker
 addUserKnob {1 output +INVISIBLE}
 output "\[knob tile_color \[value presets]]\[value knob.tags]"
 addUserKnob {4 presets M {"2004318207\tmarker" "0\tRead" "24576\tDeep" "1908830719\tRoto/Paint" "2654757887\tChannel" "2617245696\t3D / Scanline" "16711935\tkeyer" "2963561983\tTime" "3165597183\tWrite" "1993542655\tSTMap" "3241845759\tDev" "3448063\tCustom 001" "782318079\tCustom 002 " "" "" "" "" ""}}
 addUserKnob {1 tags l Tags t "Comma-separated tags for organization"}
 addUserKnob {22 rename l "   rename   " t "Rename this marker" T "import nuke\nn = nuke.thisNode()\nold = n.name()\nresult = nuke.getInput('Rename', 'New name (' + old + '):')\nif result and result != old:\n    clean = result.replace(' ', '_')\n    if not nuke.exists(clean):\n        n.setName(clean)\n        # Update any Connect nodes\n        for node in nuke.allNodes():\n            if (hasattr(node, 'knob') and node.knob('targetMarker') and \n                node\['targetMarker'].value() == old):\n                node\['targetMarker'].setValue(clean)\n        nuke.message('Renamed to: ' + clean)\n    else:\n        nuke.message('Name already exists')" +STARTLINE}
 addUserKnob {20 connect l Connect}
 addUserKnob {22 createConnect l "create connect" +STARTLINE}
 addUserKnob {22 selectConnects l "select connected" t "Select all Connect nodes referencing this marker" -STARTLINE T "marker = nuke.thisNode()\nname = marker.name()\nfor n in nuke.allNodes():\n    n.setSelected(False)\nfound = 0\nfor n in nuke.allNodes():\n    if (hasattr(n, 'knob') and n.knob('parent') and\n        n\['parent'].value() == name):\n        n.setSelected(True)\n        found += 1\nif found:\n    nuke.message('Selected ' + str(found) + ' Connect nodes')\nelse:\n    nuke.message('No Connect nodes found')"}
 addUserKnob {22 reconnectAll l "reconnect all" t "Update all Connect node indexes" -STARTLINE T "markers = \[]\nfor n in nuke.allNodes():\n    if (hasattr(n, 'knob') and n.knob('CLASSIFICATION') and\n        n\['CLASSIFICATION'].value() == 'Marker'):\n        markers.append(n.name())\n\nmarkers.sort()\nupdated_count = 0\nskipped_count = 0\n\nfor n in nuke.allNodes():\n    if (hasattr(n, 'knob') and n.knob('CLASSIFICATION') and\n        n\['CLASSIFICATION'].value() == 'Connect'):\n        \n        # Check current state\n        parent_knob = n.knob('parent')\n        input_node = n.input(0)\n        \n        if parent_knob:\n            parent_value = parent_knob.value()\n            \n            # Check if properly connected\n            if input_node and parent_value == input_node.name():\n                skipped_count += 1\n                continue\n            \n            # Try to connect if parent is set but not connected\n            if parent_value:\n                target_node = nuke.toNode(parent_value)\n                if target_node:\n                    n.setInput(0, target_node)\n                    updated_count += 1\n\nnuke.message('Connected ' + str(updated_count) + ' Connect nodes')"}
 addUserKnob {20 info l Info}
 addUserKnob {26 version l "" +STARTLINE T "<font size=\"5\">Marker</font><font color=#777777> v1.0</font>"}
 addUserKnob {26 ""}
 addUserKnob {26 description l "" +STARTLINE T "<strong>•</strong> <b>Marker</b> act as reference anchors/bookmark<br>for organizing complex node graphs\n<br><i><br>\n<strong>•</strong> Create Connect nodes to link back to<br>this marker from anywhere in your comp\n<br>\n<strong>•</strong> Essential for navigation in large<br>node networks and complex workflows<br> \n<strong>•</strong> Use \"Create Connect\" to generate reference<br>nodes that maintain visual organization<br><br>\n<b><a href=\"https://johntothvfx.com\" style=\"color:#777777;\">John Toth © 2024</a></b><br>"}
 addUserKnob {26 ""}
 addUserKnob {22 demo l "<a href=\"https://johntothvfx.com\"><span style=\"color:#777777\">Tool Demo</span></a>" t "Launches the web page where it will have more documentation or a video about the node." +INVISIBLE T "nuke.message(\"coming soon\")" +STARTLINE}
 addUserKnob {22 log l "<a href=\"https://johntothvfx.com\"><span style=\"color:#777777\">Version Log</span></a>" t "Contains information about this node.\n\n- classification\n- context\n- date last modified\n- developer notes\n- version number\n- version log\n- year made" -STARTLINE T "\nversion_number = \"1.0.0\"\ncontext = \"Other/Marker\"\nmodified_date = \"5th June 2025\"\ndeveloper = \"John Toth © 2024\"\nsite = \"<a href='website linke here'><span style='color:#BBBBBB'>\"\nlog = \"\"\"\n<br></i><b> v 1.0 </b><i>\n- connects the input of the node based on the parent\n\"\"\"\nthank_you = \" Special thanks to Samantha Maiolo for earlier development for this tool\"\n\n# Retrieve node name\nname = nuke.thisNode()\['CLASSIFICATION'].getValue()\n\n# Message components\nheader = \"Version Log:\"\ndlm = \"<b>Date Last Modified: </b>\" + modified_date\nspace = \" \"\nenter = \"<br><br>\"\nupper = \"<b>\"\nlower = \"</b>\"\n\n# Formatted message\nmessage = (\n    f\"\{upper\}\{header\}\{enter\}\"\n    f\"Name: \{lower\}\{name\}<br>\"\n    f\"\{upper\}Version Number: \{lower\}\{version_number\}<br>\"\n    f\"\{upper\}Context: \{lower\}\{context\}\{enter\}\"\n    f\"\{dlm\}\{log\}<br>\"\n    f\"<b>Thank You:</b><br>\{thank_you\}<br>\{enter\}\"\n    f\"</i>\{upper\}\{site\}\{developer\}\{lower\}</span></a>\"\n)\n\n# Display the message\nnuke.message(message)"}
}
