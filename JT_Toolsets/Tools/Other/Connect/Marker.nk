NoOp {
 name camera
 onCreate "import nuke\n\nn = nuke.thisNode()\n\n# Check if this is initial creation or a duplicate/copy\nif '_copy_' in n.name() or (n.knob('tags') and n\['tags'].value()):\n    # This is a copy/duplicate - handle naming\n    current_name = n.name().replace('_copy_1', '').replace('_copy_2', '').replace('_copy_3', '')\n\n    # If the current name doesn't exist, keep it as is\n    if not nuke.exists(current_name):\n        n.setName(current_name)\n    else:\n        # Name exists - make it unique\n        i = 1\n        while nuke.exists(current_name + '_copy_' + str(i)):\n            i += 1\n        n.setName(current_name + '_copy_' + str(i))\n    \n    # Clear onCreate and set new code for future copies\n    conflict_code = \"\"\"import nuke\n\nn = nuke.thisNode()\ncurrent_name = n.name()\n\n# Check if another node has the same name\nall_nodes = nuke.allNodes()\nconflicting_nodes = \[node for node in all_nodes if node.name() == current_name and node != n]\n\nif conflicting_nodes:\n    result = nuke.getInput('Name Conflict', 'Another node named \"' + current_name + '\" exists. Enter new name:')\n    if result:\n        clean = result.replace(' ', '_').replace('-', '_')\n        # Make unique\n        if nuke.exists(clean):\n            i = 1\n            while nuke.exists(clean + '_' + str(i)):\n                i += 1\n            clean = clean + '_' + str(i)\n        n.setName(clean)\n    else:\n        # User cancelled - make it unique automatically\n        i = 1\n        while nuke.exists(current_name + '_' + str(i)):\n            i += 1\n        n.setName(current_name + '_' + str(i))\n\"\"\"\n    n\['onCreate'].setValue(conflict_code)\n\nelse:\n    # Initial creation - show naming popup\n    result = nuke.getInput('Create Marker', 'Enter marker name:')\n    if result:\n        clean = result.replace(' ', '_').replace('-', '_')\n        # Simple uniqueness check\n        if nuke.exists(clean):\n            i = 1\n            while nuke.exists(clean + '_' + str(i)):\n                i += 1\n            clean = clean + '_' + str(i)\n        n.setName(clean)\n    else:\n        # User cancelled - use default\n        i = 1\n        while nuke.exists('Marker_' + str(i)):\n            i += 1\n        n.setName('Marker_' + str(i))\n    \n    # Clear onCreate and set new code for future copies\n    conflict_code = \"\"\"import nuke\n\nn = nuke.thisNode()\ncurrent_name = n.name()\n\n# Check if another node has the same name\nall_nodes = nuke.allNodes()\nconflicting_nodes = \[node for node in all_nodes if node.name() == current_name and node != n]\n\nif conflicting_nodes:\n    result = nuke.getInput('Name Conflict', 'Another node named \"' + current_name + '\" exists. Enter new name:')\n    if result:\n        clean = result.replace(' ', '_').replace('-', '_')\n        # Make unique\n        if nuke.exists(clean):\n            i = 1\n            while nuke.exists(clean + '_' + str(i)):\n                i += 1\n            clean = clean + '_' + str(i)\n        n.setName(clean)\n    else:\n        # User cancelled - make it unique automatically\n        i = 1\n        while nuke.exists(current_name + '_' + str(i)):\n            i += 1\n        n.setName(current_name + '_' + str(i))\n\"\"\"\n    n\['onCreate'].setValue(conflict_code)"
 tile_color 0x777777ff
 selected true
 addUserKnob {20 Marker}
 addUserKnob {1 CLASSIFICATION +INVISIBLE}
 CLASSIFICATION Marker
 addUserKnob {1 output +INVISIBLE}
 output "\[knob tile_color \[value presets]]\[value knob.tags]"
 addUserKnob {4 presets M {"2004318207\tmarker" "0\tRead" "24576\tDeep" "1908830719\tRoto/Paint" "2654757887\tChannel" "2617245696\t3D / Scanline" "16711935\tkeyer" "2963561983\tTime" "3165597183\tWrite" "1993542655\tSTMap" "3241845759\tDev" "3448063\tCustom 001" "782318079\tCustom 002 " "" "" "" "" ""}}
 addUserKnob {1 tags l Tags t "Comma-separated tags for organization"}
 addUserKnob {22 rename l "   rename   " t "Rename this marker" T "import nuke\nn = nuke.thisNode()\nold = n.name()\nresult = nuke.getInput('Rename', 'New name (' + old + '):')\nif result and result != old:\n    clean = result.replace(' ', '_')\n    if not nuke.exists(clean):\n        n.setName(clean)\n        # Update any Connect nodes\n        for node in nuke.allNodes():\n            if (hasattr(node, 'knob') and node.knob('targetMarker') and \n                node\['targetMarker'].value() == old):\n                node\['targetMarker'].setValue(clean)\n        nuke.message('Renamed to: ' + clean)\n    else:\n        nuke.message('Name already exists')" +STARTLINE}
 addUserKnob {20 connect l Connect}
 addUserKnob {22 createConnect l "create connect" T "import nuke\n\nmarker = nuke.thisNode()\nname = marker.name()\nselected = nuke.selectedNodes()\n\n# Calculate position for the new Connect node\nif selected:\n    x = selected\[-1]\['xpos'].value() + 150\n    y = selected\[-1]\['ypos'].value() + 50\nelse:\n    x = marker\['xpos'].value() + 150\n    y = marker\['ypos'].value() + 50\n\n# Create the Group node\nconnect = nuke.createNode('Group', inpanel=False)\n\n# Set basic properties\nconnect\['xpos'].setValue(x)\nconnect\['ypos'].setValue(y)\nconnect\['tile_color'].setValue(0x666666ff)  # Start with grey, will change to blue when connected\nconnect\['label'].setValue('\[value status]')\nconnect\['hide_input'].setValue(True)\n\n# Generate unique name - just use Connect, Connect1, Connect2, etc.\ni = 1\nbase_name = 'Connect'\nif nuke.exists(base_name):\n    while nuke.exists(base_name + str(i)):\n        i += 1\n    connect.setName(base_name + str(i))\nelse:\n    connect.setName(base_name)\n\n# Add the Connect tab\nconnect.addKnob(nuke.Tab_Knob('Connect'))\n\n# Add CLASSIFICATION knob (invisible)\nclassification_knob = nuke.String_Knob('CLASSIFICATION', '')\nclassification_knob.setValue('Connect')\nclassification_knob.setFlag(nuke.INVISIBLE)\nconnect.addKnob(classification_knob)\n\n# Add parent knob\nparent_knob = nuke.String_Knob('parent', 'parent', name)\nparent_knob.setTooltip('Node name of the Marker to connect to')\nconnect.addKnob(parent_knob)\n\n# Add status knob\nstatus_knob = nuke.String_Knob('status', 'Status', 'Connected to: ' + name)\nstatus_knob.setTooltip('Current connection status')\nstatus_knob.setFlag(nuke.DISABLED)\nconnect.addKnob(status_knob)\n\n# Add connectFromIndex button\nconnectFromIndex_code = '''import nuke\n\ndef show_searchable_marker_selector():\n    # Try to import Qt\n    try:\n        from PySide2 import QtWidgets, QtCore\n        from PySide2.QtCore import Qt\n    except ImportError:\n        try:\n            from PySide import QtGui as QtWidgets\n            from PySide import QtCore\n            from PySide.QtCore import Qt\n        except ImportError:\n            # Fallback to simple choice\n            markers = \[]\n            with nuke.thisParent():\n                for n in nuke.allNodes():\n                    if (hasattr(n, 'knob') and n.knob('CLASSIFICATION') and \n                        n\['CLASSIFICATION'].value() == 'Marker'):\n                        markers.append(n.name())\n            \n            if not markers:\n                nuke.message('No markers found')\n                return None\n            else:\n                choice = nuke.choice('Select Marker', 'Choose marker:', markers)\n                return markers\[choice] if choice is not None else None\n    \n    class SearchableMarkerSelector(QtWidgets.QDialog):\n        def __init__(self, parent=None):\n            super(SearchableMarkerSelector, self).__init__(parent)\n            self.setWindowTitle('Select Marker')\n            self.setModal(True)\n            self.selected_marker = None\n            self.all_markers = \[]\n            self.setupUI()\n            self.populateMarkers()\n            \n        def setupUI(self):\n            layout = QtWidgets.QVBoxLayout()\n            \n            header = QtWidgets.QLabel('Choose a Marker to connect to:')\n            header.setStyleSheet('font-weight: bold; margin-bottom: 5px;')\n            layout.addWidget(header)\n            \n            # Search box\n            search_layout = QtWidgets.QHBoxLayout()\n            search_label = QtWidgets.QLabel('Search:')\n            self.search_box = QtWidgets.QLineEdit()\n            self.search_box.setPlaceholderText('Type to filter markers...')\n            self.search_box.textChanged.connect(self.filterMarkers)\n            search_layout.addWidget(search_label)\n            search_layout.addWidget(self.search_box)\n            layout.addLayout(search_layout)\n            \n            # List widget\n            self.listWidget = QtWidgets.QListWidget()\n            self.listWidget.setMinimumSize(450, 300)\n            layout.addWidget(self.listWidget)\n            \n            # Status label\n            self.status_label = QtWidgets.QLabel('')\n            self.status_label.setStyleSheet('color: #666; font-size: 11px;')\n            layout.addWidget(self.status_label)\n            \n            # Buttons\n            buttonBox = QtWidgets.QDialogButtonBox()\n            self.connectBtn = buttonBox.addButton('Connect', QtWidgets.QDialogButtonBox.AcceptRole)\n            cancelBtn = buttonBox.addButton('Cancel', QtWidgets.QDialogButtonBox.RejectRole)\n            \n            self.connectBtn.setEnabled(False)\n            \n            buttonBox.accepted.connect(self.accept)\n            buttonBox.rejected.connect(self.reject)\n            \n            layout.addWidget(buttonBox)\n            self.setLayout(layout)\n            \n            self.listWidget.itemDoubleClicked.connect(self.accept)\n            self.listWidget.itemSelectionChanged.connect(self.updateConnectButton)\n            \n            self.search_box.setFocus()\n            \n        def populateMarkers(self):\n            self.all_markers = \[]\n            \n            # Search in parent context, not inside the Group\n            with nuke.thisParent():\n                for n in nuke.allNodes():\n                    if (hasattr(n, 'knob') and n.knob('CLASSIFICATION') and \n                        n\['CLASSIFICATION'].value() == 'Marker'):\n                        self.all_markers.append(\{\n                            'node_name': n.name(),\n                            'search_text': n.name().lower()\n                        \})\n            \n            self.all_markers.sort(key=lambda x: x\['node_name'].lower())\n            self.filterMarkers('')\n            \n        def filterMarkers(self, search_text=''):\n            if not hasattr(self, 'search_box'):\n                return\n                \n            search_text = self.search_box.text().lower().strip()\n            self.listWidget.clear()\n            \n            if not self.all_markers:\n                no_markers = QtWidgets.QListWidgetItem('No markers found')\n                no_markers.setFlags(no_markers.flags() & ~Qt.ItemIsSelectable)\n                self.listWidget.addItem(no_markers)\n                self.status_label.setText('No markers available')\n                return\n            \n            if search_text:\n                filtered_markers = \[\n                    marker for marker in self.all_markers \n                    if search_text in marker\['search_text']\n                ]\n            else:\n                filtered_markers = self.all_markers\n            \n            for marker in filtered_markers:\n                item = QtWidgets.QListWidgetItem(marker\['node_name'])\n                item.setData(Qt.UserRole, marker\['node_name'])\n                self.listWidget.addItem(item)\n            \n            total_count = len(self.all_markers)\n            filtered_count = len(filtered_markers)\n            \n            if search_text:\n                if filtered_count == 0:\n                    self.status_label.setText('No matches found (0 of ' + str(total_count) + ' markers)')\n                else:\n                    self.status_label.setText('Showing ' + str(filtered_count) + ' of ' + str(total_count) + ' markers')\n            else:\n                self.status_label.setText(str(total_count) + ' markers available')\n            \n            if self.listWidget.count() > 0 and filtered_markers:\n                self.listWidget.setCurrentRow(0)\n                \n        def updateConnectButton(self):\n            current_item = self.listWidget.currentItem()\n            has_valid_selection = (current_item and \n                                 current_item.data(Qt.UserRole) is not None)\n            self.connectBtn.setEnabled(has_valid_selection)\n            \n        def keyPressEvent(self, event):\n            if event.key() == Qt.Key_Return or event.key() == Qt.Key_Enter:\n                if self.connectBtn.isEnabled():\n                    self.accept()\n                return\n            elif event.key() == Qt.Key_Escape:\n                self.reject()\n                return\n            elif event.key() == Qt.Key_Down:\n                if self.search_box.hasFocus() and self.listWidget.count() > 0:\n                    self.listWidget.setFocus()\n                    self.listWidget.setCurrentRow(0)\n                    return\n            elif event.key() == Qt.Key_Up:\n                if self.listWidget.hasFocus() and self.listWidget.currentRow() == 0:\n                    self.search_box.setFocus()\n                    return\n                    \n            super(SearchableMarkerSelector, self).keyPressEvent(event)\n            \n        def accept(self):\n            current_item = self.listWidget.currentItem()\n            if current_item and current_item.data(Qt.UserRole):\n                self.selected_marker = current_item.data(Qt.UserRole)\n            super(SearchableMarkerSelector, self).accept()\n    \n    try:\n        app = QtWidgets.QApplication.instance()\n        parent = None\n        if app:\n            for widget in app.topLevelWidgets():\n                if widget.metaObject().className() == 'Foundry::UI':\n                    parent = widget\n                    break\n        \n        dialog = SearchableMarkerSelector(parent)\n        if dialog.exec_():\n            return dialog.selected_marker\n        return None\n        \n    except Exception as e:\n        nuke.message('Error creating dialog: ' + str(e))\n        return None\n\n# Execute\n# Store the node reference BEFORE calling the dialog\nconnect_node = nuke.thisNode()\n\nselected_marker = show_searchable_marker_selector()\nif selected_marker:\n    # Use the stored node reference instead of nuke.thisNode()\n    connect_node\['parent'].setValue(selected_marker)'''\n\nconnectFromIndex_knob = nuke.PyScript_Knob('connectFromIndex', 'connect from index', connectFromIndex_code)\nconnectFromIndex_knob.setTooltip('Show popup to select from available markers')\nconnectFromIndex_knob.setFlag(nuke.STARTLINE)\nconnect.addKnob(connectFromIndex_knob)\n\n# Add reconnect button\nreconnect_code = '''import nuke\nn = nuke.thisNode()\ntarget = n\['parent'].value()\n\nif not target:\n    nuke.message('No target marker set')\nelse:\n    with nuke.thisParent():\n        node = nuke.toNode(target)\n        if node:\n            n.setInput(0, node)\n            nuke.message('Reconnected to: ' + target)\n        else:\n            nuke.message('Target not found: ' + target)'''\n\nreconnect_knob = nuke.PyScript_Knob('reconnect', 'reconnect', reconnect_code)\nreconnect_knob.setTooltip('Force reconnection to target marker')\nreconnect_knob.clearFlag(nuke.STARTLINE)\nconnect.addKnob(reconnect_knob)\n\n# Add findParent button\nfindParent_code = '''import nuke\nn = nuke.thisNode()\ntarget = n\['parent'].value()\n\nif not target:\n    nuke.message('No target marker set')\nelse:\n    with nuke.thisParent():\n        node = nuke.toNode(target)\n        if node:\n            nuke.zoom(2, \[node.xpos() + node.screenWidth()//2, \n                         node.ypos() + node.screenHeight()//2])\n        else:\n            nuke.message('Target not found: ' + target)'''\n\nfindParent_knob = nuke.PyScript_Knob('findParent', 'find parent', findParent_code)\nfindParent_knob.setTooltip('Locate and zoom to the target marker')\nfindParent_knob.clearFlag(nuke.STARTLINE)\nconnect.addKnob(findParent_knob)\n\n# Add Utilities tab\nconnect.addKnob(nuke.Tab_Knob('utilities', 'Utilities'))\n\n# Add findConnected button\nfindConnected_code = '''import nuke\nconnect_node = nuke.thisNode()\nparent_name = connect_node\['parent'].value()\n\nprint('=== DEBUG Find Connected ===')\nprint('Current Connect node: ' + connect_node.name())\nprint('Parent name: \"' + str(parent_name) + '\"')\n\nif not parent_name:\n    nuke.message('No parent marker set')\nelse:\n    # Search in parent context, not inside the Group!\n    with nuke.thisParent():\n        # Deselect all\n        for n in nuke.allNodes():\n            n.setSelected(False)\n        \n        found = 0\n        print('Checking all nodes in parent context...')\n        \n        for n in nuke.allNodes():\n            node_name = n.name()\n            \n            # Check if it has parent knob\n            if hasattr(n, 'knob') and n.knob('parent'):\n                try:\n                    node_parent = n\['parent'].value()\n                    print('Node: ' + node_name + ' -> parent: \"' + str(node_parent) + '\"')\n                    \n                    if node_parent == parent_name and n.name() != connect_node.name():\n                        print('  -> MATCH! Selecting ' + node_name)\n                        n.setSelected(True)\n                        found += 1\n                    elif node_parent == parent_name:\n                        print('  -> Match but skipping self: ' + node_name)\n                    else:\n                        print('  -> No match')\n                except Exception as e:\n                    print('  -> Error reading parent: ' + str(e))\n            else:\n                print('Node: ' + node_name + ' -> No parent knob')\n        \n        print('=== DEBUG SUMMARY ===')\n        print('Total found: ' + str(found))\n        print('=====================')\n        \n        if found:\n            nuke.message('Selected ' + str(found) + ' Connect nodes targeting: ' + parent_name)\n        else:\n            nuke.message('No other Connect nodes found targeting: ' + parent_name)'''\n\nfindConnected_knob = nuke.PyScript_Knob('findConnected', 'find connected', findConnected_code)\nfindConnected_knob.setTooltip('Select all Connect nodes that reference the same parent Marker')\nfindConnected_knob.setFlag(nuke.STARTLINE)\nconnect.addKnob(findConnected_knob)\n\n# Add hideInputToggle button\nhideInputToggle_code = '''import nuke\n\ndef hideInputToggle():\n    node = nuke.thisNode()\n    knob = node.knob('hideInputToggle')\n    hide_input_knob = node.knob('hide_input')\n    \n    if hide_input_knob is not None:\n        # Toggle the actual hide_input value\n        current_value = hide_input_knob.value()\n        hide_input_knob.setValue(not current_value)\n        \n        # Update button label based on new state\n        if hide_input_knob.value():\n            knob.setLabel('show input')\n        else:\n            knob.setLabel('hide input')\n\n# Run the function\nhideInputToggle()'''\n\nhideInputToggle_knob = nuke.PyScript_Knob('hideInputToggle', 'show input', hideInputToggle_code)\nhideInputToggle_knob.setTooltip('Toggle input visibility')\nhideInputToggle_knob.clearFlag(nuke.STARTLINE)\nconnect.addKnob(hideInputToggle_knob)\n\n# Add togglePostageStamp button\ntogglePostageStamp_code = '''import nuke\n\ndef togglePostageStamp():\n    node = nuke.thisNode()\n    knob = node.knob('togglePostageStamp')\n    postage_knob = node.knob('postage_stamp')\n    \n    if postage_knob is not None:\n        # Toggle the actual postage_stamp value\n        current_value = postage_knob.value()\n        postage_knob.setValue(not current_value)\n        \n        # Update button label based on new state\n        if postage_knob.value():\n            knob.setLabel('hide stamp')\n        else:\n            knob.setLabel('show stamp')\n\n# Run the function\ntogglePostageStamp()'''\n\ntogglePostageStamp_knob = nuke.PyScript_Knob('togglePostageStamp', 'show stamp', togglePostageStamp_code)\ntogglePostageStamp_knob.setTooltip('Toggle postage stamp visibility')\ntogglePostageStamp_knob.clearFlag(nuke.STARTLINE)\nconnect.addKnob(togglePostageStamp_knob)\n\n# Add Info tab\nconnect.addKnob(nuke.Tab_Knob('info', 'Info'))\n\n# Add version text\nversion_knob = nuke.Text_Knob('version', '', '<font size=\"5\">Connect</font><font color=#777777> v1.2</font>')\nversion_knob.setFlag(nuke.STARTLINE)\nconnect.addKnob(version_knob)\n\n# Add empty line\nconnect.addKnob(nuke.Text_Knob('', ''))\n\n# Add description\ndescription_text = '''<strong>•</strong> <b>Connect nodes</b> act as reference points<br>that link back to this marker\n<br><i><br>\n<strong>•</strong> Set the \"parent\" field to the target marker<br>name, then use \"Connect\"\n<br>\n<strong>•</strong> Provides quick navigation and organization<br>in complex node graphs<br> \n<strong>•</strong> Maintains visual connection without affecting<br>the actual node flow<br><br>\n<b><a href=\"https://johntothvfx.com\" style=\"color:#777777;\">John Toth © 2022</a></b><br>'''\n\ndescription_knob = nuke.Text_Knob('description', '', description_text)\ndescription_knob.setFlag(nuke.STARTLINE)\nconnect.addKnob(description_knob)\n\n# Add empty line\nconnect.addKnob(nuke.Text_Knob('', ''))\n\n# Add demo button (invisible)\ndemo_knob = nuke.PyScript_Knob('demo', '<a href=\"https://johntothvfx.com\"><span style=\"color:#777777\">Tool Demo</span></a>', 'nuke.message(\"coming soon\")')\ndemo_knob.setTooltip('Launches the web page where it will have more documentation or a video about the node.')\ndemo_knob.setFlag(nuke.INVISIBLE)\ndemo_knob.setFlag(nuke.STARTLINE)\nconnect.addKnob(demo_knob)\n\n# Add version log button\nlog_code = '''\nversion_number = \"1.2.1\"\ncontext = \"Other/Connect\"\nmodified_date = \"5th June 2025\"\ndeveloper = \"John Toth © 2022\"\nsite = \"<a href='website linke here'><span style='color:#BBBBBB'>\"\nlog = \"\"\"\n<br></i><b> v 1.0 </b><i>\n- connects the input of the node based on the parent\n<br></i><b> v 1.1 </b><i>\n- index list was added to keep an list of all connect nodes to speed up workflow.\n<br></i><b> v 1.2 </b><i>\n- index now works through a difference system that works more dynamically\n- marker system implementation has been added\n- cleaner interface\n\"\"\"\nthank_you = \" Special thanks to Samantha Maiolo for earlier development for this tool\"\n\n# Retrieve node name\nname = nuke.thisNode()\['CLASSIFICATION'].getValue()\n\n# Message components\nheader = \"Version Log:\"\ndlm = \"<b>Date Last Modified: </b>\" + modified_date\nspace = \" \"\nenter = \"<br><br>\"\nupper = \"<b>\"\nlower = \"</b>\"\n\n# Formatted message\nmessage = (\n    f\"\{upper\}\{header\}\{enter\}\"\n    f\"Name: \{lower\}\{name\}<br>\"\n    f\"\{upper\}Version Number: \{lower\}\{version_number\}<br>\"\n    f\"\{upper\}Context: \{lower\}\{context\}\{enter\}\"\n    f\"\{dlm\}\{log\}<br>\"\n    f\"<b>Thank You:</b><br>\{thank_you\}<br>\{enter\}\"\n    f\"</i>\{upper\}\{site\}\{developer\}\{lower\}</span></a>\"\n)\n\n# Display the message\nnuke.message(message)'''\n\nlog_knob = nuke.PyScript_Knob('log', '<a href=\"https://johntothvfx.com\"><span style=\"color:#777777\">Version Log</span></a>', log_code)\nlog_knob.setTooltip('Contains information about this node.\\n\\n- classification\\n- context\\n- date last modified\\n- developer notes\\n- version number\\n- version log\\n- year made')\nlog_knob.clearFlag(nuke.STARTLINE)\nconnect.addKnob(log_knob)\n\n# Set the onCreate code\nonCreate_code = '''import nuke\n# Set unique name\ni = 1\nwhile nuke.exists('Connect_' + str(i)):\n    i += 1\nnuke.thisNode().setName('Connect_' + str(i))\n# Try auto-reconnect if targetMarker is set\nn = nuke.thisNode()\nif n.knob('parent') and n\['parent'].value():\n    target = n\['parent'].value()\n    with nuke.thisParent():\n        node = nuke.toNode(target)\n        if node:\n            n.setInput(0, node)'''\n\nconnect\['onCreate'].setValue(onCreate_code)\n\n# Set the knobChanged code\nknobChanged_code = '''import nuke\nn = nuke.thisNode()\nk = nuke.thisKnob()\n\nif k.name() == 'parent':\n    target = n\['parent'].value()\n    if target:\n        with nuke.thisParent():\n            node = nuke.toNode(target)\n            if node:\n                n.setInput(0, node)\n                n\['status'].setValue('Connected to: ' + target)\n                n\['tile_color'].setValue(0x4a90e2ff)\n            else:\n                n\['status'].setValue('ERROR: ' + target + ' not found')\n                n\['tile_color'].setValue(0xff4444ff)\n    else:\n        n.setInput(0, None)\n        n\['status'].setValue('No Parent Set')\n        n\['tile_color'].setValue(0x666666ff)\n\nelif k.name() == 'inputChange':\n    target = n\['parent'].value()\n    input_node = n.input(0)\n    \n    if not input_node:\n        n\['tile_color'].setValue(0xff4444ff)\n        if target:\n            n\['status'].setValue('Disconnected from: ' + target)\n        else:\n            n\['status'].setValue('No connection')\n    elif target and input_node.name() == target:\n        n\['tile_color'].setValue(0x4a90e2ff)\n        n\['status'].setValue('(' + target + ')')\n    else:\n        n\['tile_color'].setValue(0xffa500ff)\n        if input_node:\n            n\['status'].setValue('Wrong connection: ' + input_node.name())\n        else:\n            n\['status'].setValue('Connection mismatch')'''\n\nconnect\['knobChanged'].setValue(knobChanged_code)\n\n# Now we need to create the internal Input and Output nodes\n# Go inside the group\nconnect.begin()\n\n# Create Input node\ninput_node = nuke.createNode('Input', inpanel=False)\ninput_node\['xpos'].setValue(0)\ninput_node\['ypos'].setValue(-200)\ninput_node\['label'].setValue('\[value number]')\n\n# Create Output node\noutput_node = nuke.createNode('Output', inpanel=False)\noutput_node\['xpos'].setValue(0)\noutput_node\['ypos'].setValue(-100)\n\n# End group editing\nconnect.end()\n\n# Connect the group to the marker\nconnect.setInput(0, marker)\n\n# Final setup - keep the simple name\n# Select the new Connect node\nfor n in nuke.allNodes():\n    n.setSelected(False)\nconnect.setSelected(True)\n\nnuke.message('populated: ' + connect.name())" +STARTLINE}
 addUserKnob {22 selectConnects l "select connected" t "Select all Connect nodes referencing this marker" -STARTLINE T "marker = nuke.thisNode()\nname = marker.name()\nfor n in nuke.allNodes():\n    n.setSelected(False)\nfound = 0\nfor n in nuke.allNodes():\n    if (hasattr(n, 'knob') and n.knob('parent') and\n        n\['parent'].value() == name):\n        n.setSelected(True)\n        found += 1\nif found:\n    nuke.message('Selected ' + str(found) + ' Connect nodes')\nelse:\n    nuke.message('No Connect nodes found')"}
 addUserKnob {22 reconnectAll l "reconnect all" t "Update all Connect node indexes" -STARTLINE T "markers = \[]\nfor n in nuke.allNodes():\n    if (hasattr(n, 'knob') and n.knob('CLASSIFICATION') and\n        n\['CLASSIFICATION'].value() == 'Marker'):\n        markers.append(n.name())\n\nmarkers.sort()\nupdated_count = 0\nskipped_count = 0\n\nfor n in nuke.allNodes():\n    if (hasattr(n, 'knob') and n.knob('CLASSIFICATION') and\n        n\['CLASSIFICATION'].value() == 'Connect'):\n        \n        # Check current state\n        parent_knob = n.knob('parent')\n        input_node = n.input(0)\n        \n        if parent_knob:\n            parent_value = parent_knob.value()\n            \n            # Check if properly connected\n            if input_node and parent_value == input_node.name():\n                skipped_count += 1\n                continue\n            \n            # Try to connect if parent is set but not connected\n            if parent_value:\n                target_node = nuke.toNode(parent_value)\n                if target_node:\n                    n.setInput(0, target_node)\n                    updated_count += 1\n\nnuke.message('Connected ' + str(updated_count) + ' Connect nodes')"}
 addUserKnob {20 info l Info}
 addUserKnob {26 version l "" +STARTLINE T "<font size=\"5\">Marker</font><font color=#777777> v1.0</font>"}
 addUserKnob {26 ""}
 addUserKnob {26 description l "" +STARTLINE T "<strong>•</strong> <b>Marker</b> act as reference anchors/bookmark<br>for organizing complex node graphs\n<br><i><br>\n<strong>•</strong> Create Connect nodes to link back to<br>this marker from anywhere in your comp\n<br>\n<strong>•</strong> Essential for navigation in large<br>node networks and complex workflows<br> \n<strong>•</strong> Use \"Create Connect\" to generate reference<br>nodes that maintain visual organization<br><br>\n<b><a href=\"https://johntothvfx.com\" style=\"color:#777777;\">John Toth © 2024</a></b><br>"}
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {22 demo l "<a href=\"https://johntothvfx.com\"><span style=\"color:#777777\">Tool Demo</span></a>" t "Launches the web page where it will have more documentation or a video about the node." +INVISIBLE T "nuke.message(\"coming soon\")" +STARTLINE}
 addUserKnob {22 log l "<a href=\"https://johntothvfx.com\"><span style=\"color:#777777\">Version Log</span></a>" t "Contains information about this node.\n\n- classification\n- context\n- date last modified\n- developer notes\n- version number\n- version log\n- year made" -STARTLINE T "\nversion_number = \"1.0.0\"\ncontext = \"Other/Marker\"\nmodified_date = \"5th June 2025\"\ndeveloper = \"John Toth © 2024\"\nsite = \"<a href='website linke here'><span style='color:#BBBBBB'>\"\nlog = \"\"\"\n<br></i><b> v 1.0 </b><i>\n- connects the input of the node based on the parent\n\"\"\"\nthank_you = \" Special thanks to Samantha Maiolo for earlier development for this tool\"\n\n# Retrieve node name\nname = nuke.thisNode()\['CLASSIFICATION'].getValue()\n\n# Message components\nheader = \"Version Log:\"\ndlm = \"<b>Date Last Modified: </b>\" + modified_date\nspace = \" \"\nenter = \"<br><br>\"\nupper = \"<b>\"\nlower = \"</b>\"\n\n# Formatted message\nmessage = (\n    f\"\{upper\}\{header\}\{enter\}\"\n    f\"Name: \{lower\}\{name\}<br>\"\n    f\"\{upper\}Version Number: \{lower\}\{version_number\}<br>\"\n    f\"\{upper\}Context: \{lower\}\{context\}\{enter\}\"\n    f\"\{dlm\}\{log\}<br>\"\n    f\"<b>Thank You:</b><br>\{thank_you\}<br>\{enter\}\"\n    f\"</i>\{upper\}\{site\}\{developer\}\{lower\}</span></a>\"\n)\n\n# Display the message\nnuke.message(message)"}
}
