BackdropNode {
 inputs 0
 name BackdropNode1
 help "Allows the user to save the colors as presets and categorized based on department."
 onCreate "import nuke\nimport re\nimport os\n\nclass BackdropPresets:\n    def __init__(self):\n        self.default_list()\n\n    def default_list(self):\n        self.presets = \{\n            \"compositing\": \{\n                \"default\": (\"Custom\", 555819519),\n                \"default subfolder\": (\"Custom\", 808464639),\n                \"default subfolder 2\": (\"Custom\", 2341178367),\n                \"despil\": (\"Compositing\", 1363226367),\n                \"key\": (\"Compositing\", 11600127),\n                \"roto\": (\"Compositing\", 1214990079),\n                \"paint\": (\"Compositing\", 777072383),\n                \"3d\": (\"Compositing\", 1360471295),\n                \"3d subfolder\": (\"Compositing\", 1361981183),\n                \"deep\": (\"Compositing\", 522994687),\n                \"deep subfolder\": (\"Compositing\", 776032767),\n                \"lens\": (\"Compositing\", 1361986047),\n                \"chromatic aberration\": (\"Compositing\", 774787583),\n                \"optical\": (\"Compositing\", 522994687),\n                \"transform\": (\"Compositing\", 492260095),\n                \"channel\": (\"Compositing\", 3141102335),\n                \"filter\": (\"Compositing\", 3429379327),\n                \"flares\": (\"Compositing\", 1900395775),\n                \"grades\": (\"Compositing\", 2057961471),\n                \"particles\": (\"Compositing\", 3435973887),\n                \"write\": (\"Compositing\", 3719640575),\n            \},\n            \"lighting\": \{\n                \"CHR\": (\"Lighting\", 2895053055),\n                \"CWD\": (\"Lighting\", 2805793023),\n                \"EFX\": (\"Lighting\", 2768289023),\n                \"ENV\": (\"Lighting\", 285212671),\n                \"FX\": (\"Lighting\", 656300287),\n                \"PRP\": (\"Lighting\", 324141311),\n                \"SXT\": (\"Lighting\", 6209551),\n                \"SHW\": (\"Lighting\", 1397969657000000000),\n                \"VHL\": (\"Lighting\", 1397969919),\n            \}\n        \}\n\n    def refresh_presets(self):\n        node = nuke.thisNode()\n        preset_load_knob = node.knob('presetLoad')\n        preset_load_color_knob = node.knob('presetLoadColor')\n        mode_knob = node.knob('mode')\n    \n        if preset_load_knob and preset_load_color_knob and mode_knob:\n            current_preset_load_value = preset_load_knob.value()\n            current_preset_load_color_value = preset_load_color_knob.value()\n    \n            mode_value = int(mode_knob.getValue())\n    \n            department_values = \{\}\n            knob_names = \[]\n            interface_values = \{\}\n    \n            for knob_name in node.knobs():\n                knob = node.knob(knob_name)\n                if knob_name.startswith('knob') and knob_name.endswith('_department'):\n                    department_name = knob_name.replace('_department', '')\n                    department_values\[department_name] = knob.value()\n                elif knob_name.startswith('knob') and knob_name.endswith('_name'):\n                    knob_names.append(knob_name)\n                elif knob_name.startswith('knob') and knob_name.endswith('_interface'):\n                    interface_name = knob_name.replace('_interface', '')\n                    try:\n                        interface_value = knob.value()\n                        if interface_value != \"\":  # Check for empty string before converting to int\n                            interface_values\[interface_name] = int(interface_value)\n                    except ValueError:\n                        print(f\"Non-integer value found for \{knob_name\}, skipping.\")\n                        continue\n    \n            preset_load_knob.setValues(\[])\n            preset_load_color_knob.setValues(\[])\n    \n            combined_values = \[]\n            combined_color_values = \[]\n    \n            if mode_value == 0:\n                for department, items in self.presets.items():\n                    for name, (dep_name, interface_value) in items.items():\n                        combined_value = f\"\{dep_name\}/\{name\}\"\n                        combined_color_value = f\"\{dep_name\}/\{interface_value\}\"\n                        combined_values.append((dep_name, name, combined_value))\n                        combined_color_values.append((dep_name, name, combined_color_value))\n    \n                for knob_name in knob_names:\n                    knob_value = node\[knob_name].value()\n                    if knob_value:\n                        base_name = knob_name.replace('_name', '')\n                        if base_name in department_values:\n                            combined_value = f\"\{department_values\[base_name]\}/\{knob_value\}\"\n                            combined_values.append((department_values\[base_name], knob_value, combined_value))\n                            if base_name in interface_values:\n                                combined_color_value = f\"\{department_values\[base_name]\}/\{interface_values\[base_name]\}\"\n                                combined_color_values.append((department_values\[base_name], knob_value, combined_color_value))\n    \n            elif mode_value == 1:\n                for knob_name in knob_names:\n                    knob_value = node\[knob_name].value()\n                    base_name = knob_name.replace('_name', '')\n                    if knob_value and base_name in department_values:\n                        combined_value = f\"\{department_values\[base_name]\}/\{knob_value\}\"\n                        combined_values.append((department_values\[base_name], knob_value, combined_value))\n                        if base_name in interface_values:\n                            combined_color_value = f\"\{department_values\[base_name]\}/\{interface_values\[base_name]\}\"\n                            combined_color_values.append((department_values\[base_name], knob_value, combined_color_value))\n    \n            combined_values.sort(key=lambda x: (x\[0], x\[1]))\n            combined_color_values.sort(key=lambda x: (x\[0], x\[1]))\n    \n            sorted_values = \[value\[2] for value in combined_values]\n            sorted_color_values = \[value\[2] for value in combined_color_values]\n    \n            preset_load_knob.setValues(sorted_values)\n            preset_load_color_knob.setValues(sorted_color_values)\n    \n            preset_load_knob.setValue(\n                current_preset_load_value if current_preset_load_value in sorted_values \n                else sorted_values\[0] if sorted_values else \"\"\n            )\n    \n            preset_load_color_knob.setValue(\n                current_preset_load_color_value if current_preset_load_color_value in sorted_color_values \n                else sorted_color_values\[0] if sorted_color_values else \"\"\n            )\n    \n    def add_knobs(self):\n        store_knob_code = \"\"\"BackdropPresets().StoreKnobs(nuke.thisKnob())\\nBackdropPresets().refresh_presets()\\nnuke.message('The color values have been stored and presets have been refreshed with current stored presets.')\"\"\"\n        clear_knob_code = \"\"\"BackdropPresets().ClearStore(nuke.thisKnob())\"\"\"\n        remove_knob_code = \"\"\"BackdropPresets().RemoveKnob(nuke.thisKnob())\"\"\"\n\n        node = nuke.thisNode()\n    \n        index = \"01\"\n        while node.knob(f\"knob\{index\}_name\"):\n            index = str(int(index) + 1).zfill(2)\n        \n        index = str(index).zfill(2)\n        \n        name_knob = nuke.String_Knob(f\"knob\{index\}_name\", \" preset \")\n        name_knob.setEnabled(False)\n        name_knob.setFlag(nuke.STARTLINE)\n        name_knob.setTooltip('Name of the preset')\n    \n        department_knob = nuke.Enumeration_Knob(\n            f\"knob\{index\}_department\", \"\", \[\n                \"Animation\", \"Art Department\", \"Compositing\", \"Concept Art\", \"Creature FX\", \n                \"Custom\", \"Editorial\", \"Environment\", \"FX\", \"Layout\", \"Lighting\", \n                \"Look Development\", \"Matte Painting\", \"Matchmove\", \"Paint and Cleanup\", \n                \"Pre-Visualization (Previs)\", \"Rotoscoping\", \"Storyboarding\"\n            ]\n        )\n        department_knob.clearFlag(nuke.STARTLINE)\n        department_knob.setValue('Compositing')\n        department_knob.setTooltip('Select a department this preset belongs to')\n          \n        integer_knob = nuke.String_Knob(f\"knob\{index\}_interface\", \"\")\n        integer_knob.setVisible(False)\n        integer_knob.clearFlag(nuke.STARTLINE)\n        integer_knob.setTooltip('Color knob is converted into a decimal Nuke representation and stored')\n    \n        store_knob = nuke.PyScript_Knob(f\"knob\{index\}_store\", f\"store\")\n        store_knob.setValue(store_knob_code)    \n        store_knob.clearFlag(nuke.STARTLINE)\n        store_knob.setTooltip('Stores the values of color knobs and assigns a name to the presets, which are then added to the presets list.')\n    \n        reset_knob = nuke.PyScript_Knob(f\"knob\{index\}_clear\", \"clear\")\n        reset_knob.setValue(clear_knob_code)    \n        reset_knob.clearFlag(nuke.STARTLINE)\n        reset_knob.setTooltip('Resets the presets from the name, preset list, and color settings but leaves the knobs')  \n        \n        remove_knob = nuke.PyScript_Knob(f\"knob\{index\}_remove\", \"remove\")\n        remove_knob.setValue(remove_knob_code)\n        remove_knob.clearFlag(nuke.STARTLINE)\n        remove_knob.setTooltip('Removes the presets from the name, preset list, and color settings')  \n        \n        order_knobs = \[node.knob(k) for k in \[\n            'divider01', 'addKnobs', 'clear', 'reload', 'save', 'file_path', 'save_button', 'delete', 'info', 'version', \n            'divider04', 'bulletpoints', 'divider05', 'demo', 'log'\n        ]]\n        for knob in order_knobs:\n            node.removeKnob(knob)\n           \n        for knob in \[name_knob, department_knob, integer_knob, store_knob, reset_knob, remove_knob]:\n            node.addKnob(knob)\n            \n        for knob in order_knobs:\n            node.addKnob(knob)\n            \n        nuke.thisKnob().setFlag(0)\n        node.knob(\"divider01\").setVisible(True)\n\n    def clear_all_knobs(self):\n        node = nuke.thisNode()\n        for knob_name in list(node.knobs()):\n            if re.match(r\"knob\\d*_\", knob_name):\n                node.removeKnob(node.knob(knob_name))\n        node.knob(\"divider01\").setVisible(False)\n        preset_load_knob = node.knob('presetLoad')\n        preset_load_color_knob = node.knob('presetLoadColor')\n        if preset_load_knob:\n            preset_load_knob.setValues(\[])\n        if preset_load_color_knob:\n            preset_load_color_knob.setValues(\[])\n\n    def RemoveKnob(self, knob):\n        node = nuke.thisNode()\n        prefix = knob.name().split(\"_\")\[0] + \"_\"\n        preset_name = \"\"\n        preset_department = \"\"\n        preset_interface = \"\"\n    \n        for knobName in list(node.knobs()):\n            if knobName.startswith(prefix):\n                if knobName.endswith(\"_name\"):\n                    preset_name = node\[knobName].value()\n                elif knobName.endswith(\"_department\"):\n                    preset_department = node\[knobName].value()\n                elif knobName.endswith(\"_interface\"):\n                    preset_interface = node\[knobName].value()\n                node.removeKnob(node.knob(knobName))\n    \n        if not any(\[re.match(r\"knob\\d*_\", k) for k in node.knobs()]):\n            node.knob(\"divider01\").setVisible(False)\n    \n        if preset_name:\n            preset_load_knob = node.knob('presetLoad')\n            if preset_load_knob:\n                current_values = list(preset_load_knob.values())\n                updated_values = \[value for value in current_values if not (preset_department + '/' + preset_name) in value]\n                preset_load_knob.setValues(updated_values)\n    \n        if preset_department and preset_interface:\n            preset_load_color_knob = node.knob('presetLoadColor')\n            if preset_load_color_knob:\n                current_values = list(preset_load_color_knob.values())\n                combined_value = f\"\{preset_department\}/\{preset_interface\}\"\n                updated_values = \[value for value in current_values if not combined_value in value]\n                preset_load_color_knob.setValues(updated_values)\n\n    def rgb_to_unsigned_int(self, color):\n        \"\"\"Converts an RGB or grayscale value to a 32-bit unsigned integer.\"\"\"\n        if isinstance(color, (list, tuple)) and len(color) == 3:\n            # RGB value\n            r, g, b = (int(max(0, min(1, c)) * 255) for c in color)\n        elif isinstance(color, (int, float)):\n            # Grayscale value (apply the same value to R, G, B)\n            r = g = b = int(max(0, min(1, color)) * 255)\n        else:\n            raise TypeError(f\"Unexpected type for color value: \{type(color)\}\")\n    \n        result = (r << 24) | (g << 16) | (b << 8) | 255  # Shift and combine RGB with full alpha\n        print(f\"Debug: RGB to Int - R: \{r\}, G: \{g\}, B: \{b\}, Result: \{result\}\")  # Debugging output\n        return result\n    \n    def update_interface_from_color_knob(self, knob_name):\n        \"\"\"Fetches RGB values from the 'color' knob, converts them, and updates the specified 'interface' knob.\"\"\"\n        node = nuke.thisNode()\n        rgb_color = node\['color'].value()  # Assumes 'color' is an RGBColorKnob\n        print(f\"Debug: Original RGB values from 'color' knob: \{rgb_color\}\")  # Debugging output\n    \n        color_int = self.rgb_to_unsigned_int(rgb_color)\n        color_str = str(color_int)  # Convert the integer to a string\n        \n        if knob_name in node.knobs():\n            node\[knob_name].setValue(color_str)  # Set the string value in the knob\n            print(f\"Debug: '\{knob_name\}' knob updated with value: \{color_str\}\")  # Debugging output\n        else:\n            print(f\"Error: '\{knob_name\}' knob not found in the node.\")\n        \n        return color_str  # Return the string value for further use\n    \n    def store_color_value(self, knob_name='interface'):\n        \"\"\"Stores the string representation of the integer value of the 'color' knob into a specified knob.\"\"\"\n        color_str = self.update_interface_from_color_knob(knob_name)\n        print(f\"Debug: '\{knob_name\}' knob set to value: \{color_str\}\")\n        \n    def StoreKnobs(self, knob):\n        node = nuke.thisNode()\n        number = \"\".join(c for c in nuke.thisKnob().name() if c.isdigit())\n        knob_name = f\"knob\{number\}_interface\"\n    \n        if nuke.ask('Are you sure you want to store the color into a preset?'):\n            preset_name = nuke.getInput('Enter a name for the preset:')\n    \n            # Check if the user provided a name (preset_name is not None)\n            if preset_name:\n                # Only now set the interface value after the name is confirmed\n                color_str = self.update_interface_from_color_knob(knob_name)\n                node\[f'knob\{number\}_name'].setValue(preset_name)\n                node\[f'knob\{number\}_department'].setEnabled(False)\n                print(f\"Debug: Preset '\{preset_name\}' stored successfully with color value '\{color_str\}'.\")\n            else:\n                # User canceled the name input; exit without storing anything and without any pop-up\n                print(\"Debug: Preset name input canceled. Operation aborted.\")\n                return  # Exit the function to stop any further actions\n        else:\n            # User canceled the confirmation; exit without storing anything\n            print(\"Debug: Storing color into preset canceled by user.\")\n            return  # Exit the function to stop any further actions\n\n\n    def ClearStore(self, knob):\n        node = nuke.thisNode()\n        prefix = knob.name().split(\"_\")\[0] + \"_\"\n        preset_load_knob = node.knob('presetLoad')\n        preset_load_color_knob = node.knob('presetLoadColor')\n    \n        preset_name_knob = node.knob(prefix + 'name')\n        preset_department_knob = node.knob(prefix + 'department')\n        preset_interface_knob = node.knob(prefix + 'interface')\n        \n        preset_name = preset_name_knob.value() if preset_name_knob else \"\"\n        preset_department = preset_department_knob.value() if preset_department_knob else \"\"\n        preset_interface = preset_interface_knob.value() if preset_interface_knob else \"\"\n    \n        preset_name = str(preset_name)\n        preset_department = str(preset_department)\n        preset_interface = str(preset_interface)\n    \n        if preset_load_knob:\n            current_values = list(preset_load_knob.values())\n            updated_values = \[value for value in current_values if not (preset_department + '/' + preset_name) in value]\n            preset_load_knob.setValues(updated_values)\n    \n        if preset_load_color_knob:\n            current_values = list(preset_load_color_knob.values())\n            updated_values = \[value for value in current_values if not (preset_department + '/' + preset_interface) in value]\n            preset_load_color_knob.setValues(updated_values)\n    \n        for knobName in node.knobs():\n            if knobName.startswith(prefix) and (knobName.endswith('_interface') or knobName.endswith('_name') or knobName.endswith('_department')):\n                knob = node.knob(knobName)\n                if knob.Class() == \"Int_Knob\":\n                    knob.setValue(0)\n                else:\n                    knob.setValue(\"\")\n                    \n        for knobName in node.knobs():\n            if knobName.startswith(prefix) and knobName.endswith('_department'):\n                department_knob = node.knob(knobName)\n                if department_knob.Class() == \"Enumeration_Knob\":\n                    department_knob.setEnabled(True)\n                    \n    def saveNode(self):\n        node = nuke.thisNode()\n        print(\"SaveNode function called\")\n\n        # Directly define the file path, expanding the user directory\n        file_path = os.path.expanduser('~/.nuke/JT_Toolsets/Tools/Other/BackdropPresets/temp/')\n        \n        if not file_path or not os.path.isdir(file_path):\n            nuke.message(\"No valid file path specified or directory doesn't exist.\")\n            return\n        \n        # Ask the user if they want to save\n        confirm_save = nuke.ask(\"Do you want to save or overwrite existing user BackdropPresetsTemp?\")\n        \n        if not confirm_save:\n            nuke.message(\"Save operation canceled.\")\n            return\n        \n        # Specify the file name as \"BackdropPresetsTemp\"\n        file_name = \"BackdropPresetsTemp.nk\"\n        full_path = os.path.join(file_path, file_name)\n        \n        # Temporarily select this node\n        node.setSelected(True)\n        \n        try:\n            # Save the selected node(s) to the specified file\n            with open(full_path, 'w') as f:\n                nuke.nodeCopy(f.name)\n        finally:\n            # Deselect the node to restore the original state\n            node.setSelected(False)\n        \n        # Display the custom message\n        nuke.message(\"Backdrop Presets have been updated and saved to memory\")\n\n    def deleteNode(self):\n        # Define the file path, expanding the user directory\n        file_path = os.path.expanduser('~/.nuke/JT_Toolsets/Tools/Other/BackdropPresets/temp/')\n        file_name = \"BackdropPresetsTemp.nk\"\n        full_path = os.path.join(file_path, file_name)\n        \n        # Check if the file exists\n        if os.path.isfile(full_path):\n            # Ask the user if they want to delete the file\n            confirm_delete = nuke.ask(f\"Do you want to delete \{file_name\}?\")\n            \n            if confirm_delete:\n                try:\n                    # Delete the file\n                    os.remove(full_path)\n                    nuke.message(f\"\{file_name\} has been successfully deleted.\")\n                except Exception as e:\n                    nuke.message(f\"Error deleting \{file_name\}: \{str(e)\}\")\n            else:\n                nuke.message(\"File deletion canceled.\")\n        else:\n            nuke.message(f\"\{file_name\} does not exist at the specified path.\")\n"
 knobChanged "n = nuke.thisNode()\npreset = int(n\['presetLoad'].getValue())\nint(n\['presetLoadColor'].setValue(preset))"
 tile_color 0x212121ff
 label "<center><font size=\"1\">\[string toupper \[lindex \[split \[value presetLoad] \"/\"] 0]]</font>\n<font size=\"1\">\[lindex \[split \[value presetLoad] \"/\"] 1]</font>\n<font size=\"5\">\[value pass_name]</font>\n\n\[knob tile_color \[lindex \[split \[value presetLoadColor] \"/\"] 1]]\n\n"
 note_font "Bitstream Vera Sans Mono"
 note_font_size 24
 selected true
 xpos 16
 ypos 154
 bdwidth 412
 bdheight 333
 addUserKnob {20 backdropPresets l "Backdrop Presets"}
 addUserKnob {1 CLASSIFICATION +INVISIBLE}
 CLASSIFICATION BackdropPresets
 addUserKnob {1 pass_name l "pass name" t "Usually name of the element operation in the backdrop."}
 addUserKnob {4 mode t "<b>- default & custom presets:</b> Baked presets and custom user made presets will be displayed\n\n<b>- custom presets only:</b> custom user made presets will display only" M {"default & custom presets" "custom presets only" "" "" "" "" "" "" "" "" ""}}
 addUserKnob {68 presetLoad l presets t "Depends on the mode this will display the department and operation which will determine the color presets of the backdrop." M {Compositing/3d "Compositing/3d subfolder" Compositing/channel "Compositing/chromatic aberration" Compositing/deep "Compositing/deep subfolder" Compositing/despil Compositing/filter Compositing/flares Compositing/grades Compositing/key Compositing/lens Compositing/optical Compositing/paint Compositing/particles Compositing/roto Compositing/transform Compositing/write Custom/default "Custom/default subfolder" "Custom/default subfolder 2" Lighting/CHR Lighting/CWD Lighting/EFX Lighting/ENV Lighting/FX Lighting/PRP Lighting/SHW Lighting/SXT Lighting/VHL}}
 presetLoad Custom/default
 addUserKnob {22 reloadClone l reload t "Encase something seem to have broken this button exists.It will reload the node gathering all information again." -STARTLINE T "n = nuke.thisNode()\n\n#make functions available\nn.knob(\"reload\").execute()\n"}
 addUserKnob {26 ""}
 addUserKnob {3 padding t "This is the value of the scale distance between the nodes closest to the edge of the backdrop will be."}
 padding 50
 addUserKnob {22 snap l "snap to selected nodes" t "The backdrop will snap to the scale of the selected node and include a padding value." -STARTLINE T "this = nuke.thisNode()\nselNodes = nuke.selectedNodes()\npadding = this.knob('padding').value()\nif len(selNodes)== 0:\n\tpass\nelse:\n\tbdX = min(\[node.xpos() for node in selNodes]) - padding\n\tbdY = min(\[node.ypos() for node in selNodes]) - padding - 60\n\tbdW = max(\[node.xpos() + node.screenWidth() for node in selNodes]) + padding\n\tbdH = max(\[node.ypos() + node.screenHeight() for node in selNodes]) + padding\n\tthis.knob('xpos').setValue(bdX)\n\tthis.knob('ypos').setValue(bdY)\n\tthis.knob('bdwidth').setValue(bdW-bdX)\n\tthis.knob('bdheight').setValue(bdH-bdY)"}
 addUserKnob {20 presets l Presets}
 addUserKnob {68 presetLoadColor l "color code" t "Hideen but this has the values of the colors whcih the callback calls." +INVISIBLE M {Compositing/1360471295 Compositing/1361981183 Compositing/3141102335 Compositing/774787583 Compositing/522994687 Compositing/776032767 Compositing/1363226367 Compositing/3429379327 Compositing/1900395775 Compositing/2057961471 Compositing/11600127 Compositing/1361986047 Compositing/522994687 Compositing/777072383 Compositing/3435973887 Compositing/1214990079 Compositing/492260095 Compositing/3719640575 Custom/555819519 Custom/808464639 Custom/2341178367 Lighting/2895053055 Lighting/2805793023 Lighting/2768289023 Lighting/285212671 Lighting/656300287 Lighting/324141311 Lighting/1397969657000000000 Lighting/6209551 Lighting/1397969919}}
 presetLoadColor Custom/555819519
 addUserKnob {22 reloadDefaults l "reload defaults" t "Update will reset the presets to only the baked settings." -STARTLINE +INVISIBLE T BackdropPresets().refresh_default_list()}
 addUserKnob {18 color t "Color to be used to store and saved as preset."}
 color 0.18
 addUserKnob {6 color_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 storeTitle l <b>store</b>}
 addUserKnob {26 divider01 l "" +STARTLINE +HIDDEN}
 addUserKnob {22 addKnobs l add t "This will add 5 knobs:\n\n<b>- Preset name:</b> Name of the preset\n<b>- store button:</b> stores the values of the color\n<b>- clear button:</b> clears the preset\n<b>- remove button:</b> remove the preset completely" T BackdropPresets().add_knobs() +STARTLINE}
 addUserKnob {22 clear l "clear all" t "Removes all presets, including in the presets loading dropdown menu." -STARTLINE T "BackdropPresets().clear_all_knobs()\nBackdropPresets().refresh_presets()\nnuke.message('Presets have been cleared.')"}
 addUserKnob {22 reload t "Encase something seem to have broken this button exists.It will reload the node gathering all information again." -STARTLINE T "BackdropPresets().refresh_presets()\nnuke.message('Presets have been refreshed with current stored presets.')"}
 addUserKnob {20 save l Save}
 addUserKnob {2 file_path l "file path" t "File path of where the BackdropPreset \"temp\" will be saved."}
 file_path "\[python \{os.path.expanduser('~') + '/.nuke/JT_Toolsets/Tools/Other/BackdropPresets/temp/'\}]\n"
 addUserKnob {22 save_button l save t "This will not replace the master version but simply make a copy of it with all saved along with the presets and data in the file path directory.\n\nNext time you make a backdrop preset node it will bring the temp one. If no temp one exists it will bring in the master copy.\n\nNote:\nIf a backdrop preset temp is already stored. This will replace it. Only 1 temp can be stored at a time." -STARTLINE T BackdropPresets().saveNode()}
 addUserKnob {22 delete t "This will delete the backdrop preset temp from the file path.\n\nPlease make sure you want to delete it as after it is deleted it cannot be recovered." -STARTLINE T BackdropPresets().deleteNode()}
 addUserKnob {20 info l Info}
 addUserKnob {26 version l "" t "Node version info, for more information look at version log" +STARTLINE T "<br><font size='5'>Backdrop Presets</font><font color=#747474> v1.2"}
 addUserKnob {26 divider04 l "" +STARTLINE}
 addUserKnob {26 bulletpoints l "" t "Overview of the node" +STARTLINE T "<br><strong>•</br> \n<b>Backdrop Presets</b> allows the user to<br>save preset colors and categorized it based<br>on departments.\n\n<br></b><i>\n<br><strong>•</br> by default the backdrop comes with<br>default built in presets for artist to use.\n\n</i>\n<br><br><b><a href=\"https://johntothvfx.com\" style=\"color:#747474;\">John Toth <b>© 2024 <br>"}
 addUserKnob {26 divider05 l "" +STARTLINE}
 addUserKnob {22 demo l "<a href=\"https://johntothvfx.com\"><span style=\"color:#747474\">Tool Demo</a>\n" t "Launches the web page where it will have more documentation or a video about the node." +INVISIBLE T "nuke.message(\"Coming Soon\")" +STARTLINE}
 addUserKnob {22 log l "<a href=\"https://johntothvfx.com\"><span style=\"color:#747474\">Version Log</a>\n" t "Contains information about this node.\n\n- classification\n- context\n- date last modified\n- developer notes\n- version number\n- version log\n- year made" -STARTLINE T "\nversion_number = \"1.2.0\"\ncontext = \"Other\"\nmodified_date = \"13th August 2024\"\ndeveloper = \"John Toth © 2024\"\nsite = \"<a href='https://johntothvfx.com'><span style='color:#BBBBBB'>\"\nlog = \"\"\"\n<br></i><b> v 1.0 </b><i>\n- allows the user to save the colors as presets and categorized based on department\n<br></i><b> v 1.1 </b><i>\n- optimization\n- when gathering color it will clamp to 0-255 so no erros occur if values are invalid.\n<br></i><b> v 1.1 </b><i>\n- optimization\n- when gathering color it will clamp to 0-255 so no erros occur if values are invalid.\n<br></i><b> v 1.2 </b><i>\n- save / deleting temp backdrop preset was added\n- refining color conversion so it can handle invalid values as expected\n- user is forced to put a preset name or cancel operation\n\"\"\"\nthank_you = \"\"\n\n# Retrieve node name\nname = nuke.thisNode()\['CLASSIFICATION'].getValue()\n\n# Message components\nheader = \"Version Log:\"\ndlm = \"<b>Date Last Modified: </b>\" + modified_date\nspace = \" \"\nenter = \"<br><br>\"\nupper = \"<b>\"\nlower = \"</b>\"\n\n# Formatted message\nmessage = (\n    f\"\{upper\}\{header\}\{enter\}\"\n    f\"Name: \{lower\}\{name\}<br>\"\n    f\"\{upper\}Version Number: \{lower\}\{version_number\}<br>\"\n    f\"\{upper\}Context: \{lower\}\{context\}\{enter\}\"\n    f\"\{dlm\}\{log\}<br>\"\n    #f\"<b>Thank You:</b><br>\{thank_you\}<br>\{enter\}\"\n    f\"</i>\{upper\}\{site\}\{developer\}\{lower\}</span></a>\"\n)\n\n# Display the message\nnuke.message(message)"}
}
